# WARNING - Generated by {fusen} from dev/NeighborFinder_flat.Rmd: do not edit by hand

#' Apply cv.glmnet() for a given mmodule ID
#' 
#' @param df Dataframe. A normalized dataframe
#' @param module String. The module ID name
#' @param seed Numeric. The seed number, ensuring reproducibility
#' @param covar String or formula. Formula or the name of the column of the covariate in the metadata table. Note that "study_accession" is equivalent to ~study_accession
#' @param meta_df Dataframe. The dataframe giving metadata information
#' @param sample_col String. The name of the column in metadata indicating the sample names, it should be consistent with the colnames of 'df'
#' 
#' @return Dataframe. Returns the module ID, its detected neighbor and the corresponding coefficient 
#' @export
#' @examples
#' data(data)
#' data(metadata)
#' #Simple example
#' x <- norm_data(data$CRC_JPN, 0.30, type="fpkm")[[1]]
#' neighbors_JPN<-find_module_neighbors(df=x, module="msp_0030", seed=20232024)
#' #Example with covariate
#' x <- norm_data(data$CRC_CHN, 0.30, type="fpkm")[[1]]
#' neighbors_CHN<-find_module_neighbors(df=x, module="msp_0030", seed=20232024, covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")

find_module_neighbors <- function(df, module, seed = NULL, covar = NULL, meta_df = NULL, sample_col = NULL) {
  if (is.null(seed)) {
    stop("No seed provided, make sure you've set and recorded the random seed of your session for reproducibility")
  } 
  else {set.seed(seed)}
  
  ## Build default penalty factor (in the absence of covariates)
  p <- ncol(df)-1 ## number of predictors
  penalty_factor <- rep(1, 1+p)
  penalized_features <- colnames(df)
  if (!is.null(covar)) {
    ## Stop if no metadata provided
    if (is.null(meta_df)) stop("Please provide a metadata table.") 
    ## Stop if no sample column provided
    if (is.null(sample_col)) stop("Please indicate the column of sample names in metadata.") 
    ## Process metadata to match abundance table
    if (!is.null(sample_col) && sample_col %in% colnames(meta_df)) {
      rownames(meta_df) <- meta_df[[sample_col]]
    }
    if (! all(rownames(df) %in% rownames(meta_df))) {
      stop("Some samples are missing from the metadata table.")
    }
    ## process formula to build covariate matrix
    if (!rlang::is_formula(covar)) {
      covar <- as.formula(paste("~", paste(covar, collapse = "+")))
    }
    meta_df <- meta_df[rownames(df), ]
    covariates <- model.matrix(covar, meta_df)
    covariates <- covariates[, !colnames(covariates) == "(Intersect)", drop = FALSE]
    if (nrow(covariates) < nrow(df)) {
      stop("Some samples were dropped, likely because of missing data in the covariates.")
    }
    p_covar <- ncol(covariates)
    df <- cbind(df, covariates)
    penalty_factor <- c(penalty_factor, rep(0, p_covar))
  }
  
  col <- which(module == colnames(df))
  if (!length(col)) {return(tibble::tibble(.rows = 0))}
  res_glm <- glmnet::cv.glmnet(df[,-col], df[,col], penalty.factor = penalty_factor) %>% coef(s = "lambda.min")
  tibble::tibble(node1 = module, node2 = rownames(res_glm), coef = as.numeric(res_glm)) %>%
   dplyr::filter(coef!=0, node2 %in% penalized_features) 
}
