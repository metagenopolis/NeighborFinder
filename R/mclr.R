# WARNING - Generated by {fusen} from dev/NeighborFinder_flat.Rmd: do not edit by hand

#' Modified central log ratio (mclr) transformation extracted from the SPRING package
#'
#' @param dat raw count data or compositional data (n by p) does not matter.
#' @param base exp(1) for natural log
#' @param tol tolerance for checking zeros
# For eps and atleast, users do not have to specify any values. Default should be enough.
#' @param eps epsilon in eq (2) of the paper "Yoon, Gaynanova, M\"{u}ller (2019), Frontiers in Genetics". positive shifts to all non-zero compositions. Refer to the paper for more details. eps = absolute value of minimum of log ratio counts plus c.
#' @param atleast default value is 1. Constant c which ensures all nonzero values to be strictly positive. default is 1.
#'
#' @return \code{mclr} returns a data matrix of the same dimension with input data matrix.
#' @export

mclr <- function(dat, base=exp(1), tol=1e-16, eps=NULL, atleast=1){
  dat <- as.matrix(dat)
  nzero <- (dat>=tol)  # index for nonzero part
  LOG <- ifelse(nzero, log(dat, base), 0.0) # take log for only nonzero values. zeros stay as zeros.

  # centralize by the log of "geometric mean of only nonzero part" # it should be calculated by each row.
  if (nrow(dat)>1){
    clrdat <- ifelse(nzero, LOG - rowMeans(LOG)/rowMeans(nzero), 0.0)
  } else if (nrow(dat)==1){
    clrdat <- ifelse(nzero, LOG - mean(LOG)/mean(nzero), 0.0)
  }

  if (is.null(eps)){
    if(atleast<0){
      warning("atleast should be positive. The functions uses default value 1 instead.")
      atleast=1
    }
    if( min(clrdat)<0 ){ # to find the smallest negative value and add 1 to shift all data larger than zero.
      positivecst <- abs(min(clrdat))+atleast # "atleast" has default 1.
    }else{
      positivecst <- 0
    }
    # positive shift
    ADDpos <- ifelse(nzero, clrdat+positivecst, 0.0) ## make all non-zero values strictly positive.
    return(ADDpos)
  } else if(eps==0){
    ## no shift. clr transform applied to non-zero proportions only. without pseudo count.
    return(clrdat)
  } else if(eps>0){
    ## use user-defined eps for additional positive shift.
    ADDpos <- ifelse(nzero, clrdat+eps, 0.0)
    return(ADDpos)
  } else {
    stop("check your eps value for additional positive shift. Otherwise, leave it as NULL.")
  }
}
