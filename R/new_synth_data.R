# WARNING - Generated by {fusen} from dev/flat_NeighborFinder.Rmd: do not edit by hand # nolint: line_length_linter.

#' Simulate data from some empirical count dataset with a "cluster-like" structure
#'
#' @param real_data Matrix. Empirical count table
#' @param graph_type String. Structure type for the conditional dependency structure. Here only "cluster" was kept, see EMtree package for more options
#' @param graph Boolean. Optional graph to be used, must have rownames and colnames and reference all features from real_data
#' @param n Numeric. Number of samples to simulate
#' @param r Numeric. For cluster structure, controls the within/between ratio connection probability
#' @param dens Numeric. Graph density (for cluster graphs) or edges probability (for erd√∂s-renyi graphs)
#' @param seed Numeric. Seed number for data generation (rmvnorm)
#' @param must_connect Boolean. TRUE to force the output graph to be connected
#' @param k Numeric. For cluster structure, number of groups
#' @param verbatim Boolean. Controls verbosity
#' @param signed Boolean. TRUE for simulating both positive and negative partial correlations. Default is to FALSE, which implies only negative partial correlations
#'
#' @return List. Containing the simulated discrete counts, the corresponding true partial correlation matrix from the latent Gaussian layer of the model and the original graph structure that was used
#' @export
#' @examples
#' tiny_data <- data.frame(
#'   species = c("One bacteria", "One bacterium L", "One bacterium G", "Two bact"),
#'   msp_name = c("msp_1", "msp_2", "msp_3", "msp_4"),
#'   SAMPLE1 = c(0, 1.328425e-06, 0, 1.527688e-07),
#'   SAMPLE2 = c(1.251707e-07, 1.251707e-07, 3.985320e-07, 0),
#'   SAMPLE3 = c(0, 0, 4.926046e-09, 5.626392e-06),
#'   SAMPLE4 = c(0, 0, 2.98320e-05, 0)
#' )
#'
#' count_table <- get_count_table(abund.table = tiny_data %>% dplyr::select(-species), sample.id = colnames(tiny_data), prev.min = 0.1)
#' tiny_graph <- graph_step(tiny_data, col_module_id = "msp_name", annotation_level = "species", seed = 20242025) %>% suppressWarnings()
#' sim_data <- new_synth_data(count_table$data, n = 50, graph = as.matrix(tiny_graph %>% dplyr::select(-species)), verbatim = FALSE, seed = 20242025)
new_synth_data <- function(real_data, graph_type = "cluster", must_connect = TRUE, graph = NULL, n = 300,
                           seed = 10010, r = 50, dens = 4, k = 3, verbatim = TRUE, signed = FALSE) {
  p <- ncol(real_data)
  species <- colnames(real_data)

  # Functions extracted from EMtree package to remove dependency
  ToSym <- function(A.vec) {
    n <- (1 + sqrt(1 + 8 * length(A.vec))) / 2
    A.mat <- matrix(0, n, n)
    A.mat[upper.tri(A.mat)] <- A.vec
    A.mat <- A.mat + t(A.mat)
    A.mat
  }
  ToVec <- function(A.mat) {
    return(suppressMessages(A.mat[upper.tri(A.mat)]))
  }
  SimCluster <- function(p, k, dens, r) {
    beta <- dens / (r / k + (k - 1) / k)
    alpha <- r * beta
    while (alpha > 1) {
      r <- 0.9 * r
      beta <- dens / (r / k + (k - 1) / k)
      alpha <- r * beta
    }
    Z <- t(stats::rmultinom(p, 1, rep(1 / k, k)))
    groupe <- Z %*% 1:k
    Z <- Z %*% t(Z)
    diag(Z) <- 0
    ZZ <- ToVec(Z)
    G <- ToSym(rbinom(p * (p - 1) / 2, 1, alpha * ZZ + beta * (1 - ZZ)))
    G
  }
  generator_graph <- function(p = 20, graph = "cluster", dens = 0.3, r = 2, k = 3) {
    theta <- matrix(0, p, p)
    if (graph == "cluster") {
      theta <- SimCluster(p, k = k, dens, r)
    }
    return(theta = Matrix::Matrix(theta, sparse = TRUE))
  }
  generator_param <- function(G, signed = FALSE, v = 0.01) {
    lambda <- 1
    p <- ncol(G)
    sumlignes <- rowSums(matrix(G, p, p))
    if (sum(sumlignes == 0) != 0) {
      sumlignes[sumlignes == 0] <- 0.1
    }
    D <- diag(sumlignes + v)
    if (signed) {
      Gsign <- ToSym(ToVec(G * matrix(2 * stats::rbinom(p^2, 1, 0.3) - 1, p, p)))
      omega <- lambda * D + Gsign
      while (min(eigen(omega)$values) < 1e-10 & lambda < 1000) {
        lambda <- 1.1 * lambda
        omega <- lambda * D + Gsign
      }
    } else {
      omega <- lambda * D + G
      while (min(eigen(omega)$values) < 1e-10) {
        lambda <- 1.1 * lambda
        omega <- lambda * D + G
      }
    }
    sigma <- solve(omega)
    sim <- list(Sigma = sigma, Omega = omega, Lambda = lambda)
    sim
  }

  if (is.null(graph)) {
    if (!must_connect) {
      set.seed(seed)
      G <- as.matrix(generator_graph(p = p, graph = graph_type, dens = dens / p, r, k))
    } else {
      i <- 0
      connect <- FALSE
      while (!connect) {
        i <- i + 1
        set.seed(i)
        G <- as.matrix(generator_graph(p = p, graph = graph_type, dens = dens / p, r, k))
        graph <- igraph::graph_from_adjacency_matrix(G)
        connect <- igraph::is_connected(graph)
      }
    }
  } else {
    if (!all(species %in% colnames(graph)) || !all(species %in% rownames(graph))) stop("Some species in the abundance dataset do not appear in the provided graph.")
    G <- graph[species, species]
  }
  dimnames(G) <- list(species, species)
  faithful_param <- generator_param(G = G, signed = signed)
  parcor <- -cov2cor(as.matrix(faithful_param$Omega))

  if (verbatim) cat("Simulation from real data ecdf...")

  simu_counts <- simulate_from_ecdf(real_data, Sigma = faithful_param$Sigma, n = n, seed = seed, verbatim = verbatim)
  simulated_data <- list(counts = simu_counts, par.cor = parcor, G = G)
  simulated_data
}
