<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Technical Report • neighborfinder</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Technical Report">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">neighborfinder</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/NeighborFinder_technical_report.html">Technical Report</a></li>
    <li><a class="dropdown-item" href="../articles/NeighborFinder_vignette.html">Use case</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Technical Report</h1>
            
      

      <div class="d-none name"><code>NeighborFinder_technical_report.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/rstudio/rmarkdown" class="external-link">rmarkdown</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://yihui.org/knitr/" class="external-link">knitr</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">neighborfinder</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Attaching package: 'neighborfinder'</span></span>
<span><span class="co">#&gt; The following object is masked from 'package:rmarkdown':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     metadata</span></span></code></pre></div>
<div class="section level3">
<h3 id="why-use-neighborfinder">Why use NeighborFinder?<a class="anchor" aria-label="anchor" href="#why-use-neighborfinder"></a>
</h3>
<ul>
<li><p>NeighborFinder helps you find the direct neighbors of a certain
object of interest (bacterial species, functional module, etc).</p></li>
<li><p>Applying NeighborFinder to multiple datasets makes predictions
more robust. Identified neighbors can thus be used to design microbial
communities, probiotics or live biotherapeutic products (LBP).</p></li>
<li><p>NeighborFinder can also help to identify specific ecological
niches linked to particular diseases.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="how-to-use-it">How to use it?<a class="anchor" aria-label="anchor" href="#how-to-use-it"></a>
</h3>
<ul>
<li><p>Install package cf. <a href="https://forge.inrae.fr/metagenopolis/neighborfinder" class="external-link">README</a></p></li>
<li><p>Apply it on abundance tables of metagenomic data gathering at
least 100 samples for better performance.</p></li>
<li><p>See the <a href="NeighborFinder_vignette.html">vignette</a>
included in the package. It reviews the main functions that are useful
for making the most of the NeighborFinder’s features.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="input-dataframe-format">Input dataframe format<a class="anchor" aria-label="anchor" href="#input-dataframe-format"></a>
</h3>
<p>The required data format in input is as follows: module IDs are the
rows and samples are the columns. The first column must be the <span style="color:#5594E5;"><strong>modules name</strong></span>
(e.g. species), the second is the <span style="color:#FFD91D;"><strong>module ID</strong></span> (e.g. msp), and
each subsequent column is a <span style="color:#7AD370;"><strong>sample</strong></span>. “X” is a numeric
value corresponding to an abundance provided either as count or a
metagenomic abundance. Here is an example when the <span style="color:#5594E5;"><strong>modules name</strong></span> is the
species name and the <span style="color:#FFD91D;"><strong>module
ID</strong></span> is the MSP_name.</p>
<p><img src="Technical_report_figures/fig1.jpg" width="80%" style="display: block; margin: auto;"></p>
<center>
Figure 1: Example of dataset and required format
</center>
</div>
<div class="section level3">
<h3 id="what-is-behind-apply_neighborfinder">What is behind apply_NeighborFinder() ?<a class="anchor" aria-label="anchor" href="#what-is-behind-apply_neighborfinder"></a>
</h3>
<p>Here is a description of how the function works.</p>
<p><img src="Technical_report_figures/workflow_top_only.jpg" width="100%" style="display: block; margin: auto;"></p>
<center>
Figure 2: Description of the architecture of apply_NeighborFinder()
</center>
<p><br></p>
<div class="section level4">
<h4 id="pre-processing-counts-normalization">1) Pre-processing: Counts &amp; Normalization<a class="anchor" aria-label="anchor" href="#pre-processing-counts-normalization"></a>
</h4>
<div class="section level5">
<h5 id="a-prevalence-filter-shotgun-pre-treatment">a) Prevalence filter &amp; shotgun pre-treatment<a class="anchor" aria-label="anchor" href="#a-prevalence-filter-shotgun-pre-treatment"></a>
</h5>
<p>The first step of <code><a href="../reference/apply_NeighborFinder.html">apply_NeighborFinder()</a></code> is to filter
the input abundance data, provided in the above format, using the
parameter <code>prev_level</code>. This step helps simplify the dataset
by filtering out rare species.</p>
<p>The transformation of the abundance data into a count table consists
in first transposing the data (so that the samples are in rows and the
module IDs are in columns). Then, the abundances are transformed to
counts using <code><a href="../reference/get_count_table.html">get_count_table()</a></code> extracted from the
<code>OneNet</code> package. This is done by dividing all values by the
smallest positive abundance and rounding the results, so that the
minimum count is 1.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">⌊</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>/</mi><msub><mi>A</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">B_{ij} = \lfloor A_{ij}/A_{min}\rfloor</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mtext mathvariant="normal">min</mtext></msub><mo>=</mo><msub><mo>min</mo><mrow><mo stretchy="false" form="prefix">{</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>:</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>≠</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mrow></msub><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\text{min}} = \min_{\{i,j : A_{ij} \neq 0\}} A_{ij}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is the abundance table and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
the resulting count table. Note that the rows of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
(and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>)
are samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i \in \{1,...,n\}</annotation></semantics></math>
and the columns are module IDs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>p</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">j \in \{1,...,p\}</annotation></semantics></math>.</p>
<p><br></p>
</div>
<div class="section level5">
<h5 id="b-normalization">b) Normalization<a class="anchor" aria-label="anchor" href="#b-normalization"></a>
</h5>
<p>The next step consists in applying a mclr normalization to the
previously transformed abundance data. Here is the equation
corresponding to the mclr transformation:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub><mo>=</mo><msub><mrow><mi>m</mi><mi>c</mi><mi>l</mi><mi>r</mi></mrow><mi>ϵ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>B</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_j = {mclr}_\epsilon   (B_j)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is the count table and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
the resulting normalized count table. Unlike the clr normalization, mclr
preserves the zeros in the dataset.</p>
<p>The function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>m</mi><mi>c</mi><mi>l</mi><mi>r</mi></mrow><mi>ϵ</mi></msub><annotation encoding="application/x-tex">{mclr}_\epsilon</annotation></semantics></math>
is defined as follows. Consider a vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msubsup><mi>R</mi><mo>+</mo><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">x\in R_+^p</annotation></semantics></math>
of compositions, and and without loss of generality, assume that the
ﬁrst
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
are zero, and that all other elements are positive.</p>
<p>Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>m</mi><mi>c</mi><mi>l</mi><mi>r</mi></mrow><mi>ϵ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">{mclr}_\epsilon(x)</annotation></semantics></math>
is defined by:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mrow><mi>m</mi><mi>c</mi><mi>l</mi><mi>r</mi></mrow><mi>ϵ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mn>0</mn><mo>,</mo><mo>log</mo><mo stretchy="false" form="prefix">{</mo><mrow><msub><mi>x</mi><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>/</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mo stretchy="false" form="postfix">}</mo><mo>+</mo><mi>ϵ</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mo>log</mo><mo stretchy="false" form="prefix">{</mo><mrow><msub><mi>x</mi><mi>j</mi></msub><mi>/</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mo stretchy="false" form="postfix">}</mo><mo>+</mo><mi>ϵ</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mo>log</mo><mo stretchy="false" form="prefix">{</mo><mrow><msub><mi>x</mi><mi>p</mi></msub><mi>/</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mo stretchy="false" form="postfix">}</mo><mo>+</mo><mi>ϵ</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">y= {mclr}_\epsilon(x)  = [0,...,0,\log\{{x_{q+1}/g(x)}\}+\epsilon  ,...,\log\{{x_j/g(x)}\}+\epsilon  ,...,\log\{{x_p/g(x)}\}+\epsilon ]</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mi>q</mi><mo>+</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>−</mo><mi>q</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">g(x) = {(\prod^{p}_{j=q+1}x_j)}^{1/(p-q)}</annotation></semantics></math>
is the geometric mean of the non-zero elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>.</p>
<p>When
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>m</mi><mi>c</mi><mi>l</mi><mi>r</mi></mrow><mi>ϵ</mi></msub><annotation encoding="application/x-tex">{mclr}_\epsilon</annotation></semantics></math>
is applied to the abundance table
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
we apply it rowwise (that is to each sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>B</mi><mi>i</mi></msub><annotation encoding="application/x-tex">B_i</annotation></semantics></math>)
and use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mo>∣</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>∣</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\epsilon =∣ z_{min} ∣ + 1</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><msub><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mrow><msub><mrow><mi>i</mi><mi>j</mi><mo>:</mo><mi>B</mi></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>≠</mo><mn>0</mn></mrow></msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false" form="prefix">{</mo><mrow><msub><mi>B</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>/</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>B</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">z_{min} = {min }_{{ij:B}_{ij}\neq 0}{ log\{{B_{ij}/g(B_i)}}\}</annotation></semantics></math>.</p>
<p><br></p>
</div>
</div>
<div class="section level4">
<h4 id="regularized-linear-regressions">2) Regularized linear regressions<a class="anchor" aria-label="anchor" href="#regularized-linear-regressions"></a>
</h4>
<div class="section level5">
<h5 id="a-simple-case-no-covariates">a) Simple case: no covariates<a class="anchor" aria-label="anchor" href="#a-simple-case-no-covariates"></a>
</h5>
<p>We consider a linear regression problem where we regress the
abundance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mi>j</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">C_{j0}</annotation></semantics></math>
of module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j0</annotation></semantics></math>
against the abundances of all others modules
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>C</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>j</mi><mo>≠</mo><mi>j</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">{(C_j)}_{j\neq j0}</annotation></semantics></math>.
The function <code><a href="https://glmnet.stanford.edu/reference/cv.glmnet.html" class="external-link">glmnet::cv.glmnet()</a></code> is applied on the
normalized data 10 times, each time with a different seed. The following
model is used:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>j</mi><mn>0</mn></mrow></msub><mo>=</mo><msub><mi>θ</mi><mn>1</mn></msub><msub><mi>C</mi><mn>1</mn></msub><mo>+</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>+</mo><msub><mi>θ</mi><mrow><mi>j</mi><mn>0</mn><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mi>j</mi><mn>0</mn><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>θ</mi><mrow><mi>j</mi><mn>0</mn><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mi>j</mi><mn>0</mn><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>+</mo><msub><mi>θ</mi><mi>p</mi></msub><msub><mi>C</mi><mi>p</mi></msub><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">C_{j0} = \theta_1  C_1 +...+ \theta_{j0-1}  C_{j0-1} + \theta_{j0+1}  C_{j0+1} +...+ \theta_p  C_p +\epsilon</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is the normalized count table obtained at the end of step 1) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j0</annotation></semantics></math>
designates the column of the module of interest in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\theta_j</annotation></semantics></math>
is the regression coefficient of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j0</annotation></semantics></math>
against
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>
is the residual error, assumed to be gaussian with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sigma^2  I_n</annotation></semantics></math>
covariance.</p>
<p>Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is usually bigger than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
and we want a sparse vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>,
we use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>l</mi><mn>1</mn></msub><annotation encoding="application/x-tex">l_1</annotation></semantics></math>–regularization
to select a small number of non null coefficients in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>.
The modules for which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>j</mi></msub><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_j \neq 0</annotation></semantics></math>
corresponds to a potential neighbors of module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j0</annotation></semantics></math>.</p>
<p>This translates to the following minimization problem:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>i</mi><mi>n</mi><mrow><msub><mi></mi><mi>θ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo>‖</mo><msub><mi>C</mi><mrow><mi>j</mi><mn>0</mn></mrow></msub><mo>−</mo><mi>X</mi><mi>θ</mi><mo>‖</mo></mrow><mn>2</mn></msup><mo>+</mo><msub><mrow><mi>λ</mi><mo>‖</mo><mi>θ</mi><mo>‖</mo></mrow><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">argmin{_{\theta}{({‖C_{j0}-X\theta‖}^2+{\lambda‖\theta‖}_1)}}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>X</mi><mo>=</mo><mi>C</mi></mrow><mrow><mo>−</mo><mi>j</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">{X=C}_{-j0}</annotation></semantics></math>
is the design matrix composed of the abundances of all modules but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j0</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
is the penalization term enforcing the strength of the regularization
and thus the number of non null coefficients. We solve this problem
using <code>glmnet::glasso()</code> and use cross-validation to tune the
parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</p>
<p><br></p>
</div>
<div class="section level5">
<h5 id="b-handling-covariates">b) Handling covariates<a class="anchor" aria-label="anchor" href="#b-handling-covariates"></a>
</h5>
<p>Covariates can be included in the model by considering an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
made of two distinct components:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mo>−</mo><mi>j</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">C_{-j0}</annotation></semantics></math>
, previously defined, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>,
the design matrix of the covariates.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
the metadata matrix where some columns are considered as covariates.
Here is the necessary transformation:</p>
<p><span class="math inline">$[\matrix{D&amp;C_{-j0}}]$</span> <span class="math inline">$[\matrix{\alpha\\\theta}]$</span></p>
<p>The penalization
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
only applies on coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\theta_i</annotation></semantics></math>
and not on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>.</p>
<p>Minimization of the objective function:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><mrow><mi>θ</mi><mo>,</mo><mi>α</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mo>‖</mo><msub><mi>C</mi><mrow><mi>j</mi><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>C</mi><mrow><mo>−</mo><mi>j</mi><mn>0</mn></mrow></msub><mi>θ</mi><mo>−</mo><mi>D</mi><mi>α</mi><mo>‖</mo></mrow><mn>2</mn></msub><mo>+</mo><mi>λ</mi><msub><mrow><mo>‖</mo><mi>θ</mi><mo>‖</mo></mrow><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">{minimize}_{\theta ,\alpha}  ({‖C_{j0}-C_{-j0}\theta -D\alpha ‖}_2+\lambda {‖\theta ‖}_1)</annotation></semantics></math></p>
<p>In practice,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mo>−</mo><mi>j</mi><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">C_{-j0}</annotation></semantics></math>
are concatenated into a single matrix which is used as the input of
<code>cv.glmnet()</code> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
is constructed from a covariate dataframe using either <em>(i)</em> the
formula interface, or <em>(ii)</em> specifying the name of a single
column used as covariate.</p>
<p>To use covariates, 3 additional arguments are required:</p>
<ul>
<li><p><code>covar</code>: takes a formula or the name of the column of
the covariate in the metadata table.</p></li>
<li><p><code>meta_df</code>: the dataframe giving metadata
information.</p></li>
<li><p><code>sample_col</code>: the name of the column in metadata
indicating the sample names.</p></li>
</ul>
<p>See part “Apply NeighborFinder with covariate option” in the <a href="NeighborFinder_vignette.html">vignette</a> for a detailed
example.</p>
<p><br></p>
</div>
</div>
<div class="section level4">
<h4 id="post-processing">3) Post-processing<a class="anchor" aria-label="anchor" href="#post-processing"></a>
</h4>
<div class="section level5">
<h5 id="a-filtering-the-results">a) Filtering the results<a class="anchor" aria-label="anchor" href="#a-filtering-the-results"></a>
</h5>
<p>This step enables NeighborFinder to have better performances than
with the naive glmnet method. For each seed-generated result, a filter
is applied to increase the reliability of detected interactions. This is
done with the <code>top_filtering parameter</code>: it consists in
keeping only the strongest coefficients. If <code>top_filtering</code>
is set to 10%, the coefficients conserved must be greater in absolute
value than the 90th quantile of all coefficients detected for the
neighbors of a species of interest.</p>
<p><img src="Technical_report_figures/fig3.jpg" width="100%" style="display: block; margin: auto;"></p>
<center>
Figure 3: Filtering process
</center>
</div>
<div class="section level5">
<h5 id="b-increasing-robusteness">b) Increasing robusteness<a class="anchor" aria-label="anchor" href="#b-increasing-robusteness"></a>
</h5>
<p>To gain in robustness, only neighbors detected several times are
kept. The function <code><a href="../reference/apply_NF_simple.html">apply_NF_simple()</a></code> is run on 10 seeds and
results found are kept if only found in at least half of the seeds. This
process ensures more robust results. This step merges the 10 filtered
results (each corresponding to a seed) and eliminates edges detected in
less than half of the results. For a kept interaction, the median of the
different coefficients is calculated and saved in the final output. The
final result is an edge table of the interactions that were stronger and
found in at least half of the 10 seed-generated results.</p>
<p>Performance scores were way better with this repetition approach than
running the developed method on a single seed (see Figure 4).</p>
<p><br></p>
</div>
</div>
</div>
<div class="section level3">
<h3 id="how-to-calibrate-the-parameters-values">How to calibrate the parameters values ?<a class="anchor" aria-label="anchor" href="#how-to-calibrate-the-parameters-values"></a>
</h3>
<p>The function <code>apply_neighborfinder()</code> has two important
parameters (<code>prev_level</code> and <code>top_filtering</code>) that
shape the output. It is also acknowledged that the dataset size usually
has an impact on the generated network. Our performance assessment
strategy therefore consisted in covering a range of values for both
parameters, with the aim of providing users with guidelines to pick the
most suitable combination for their dataset size. We tested the
performance of NeighborFinder on eight shotgun metagenomic cohorts
(sample sizes ranging from 347 to 1084) detailed here
doi_recherhche_data_gouv.</p>
<p>For each of the eight large cohorts, a graph with “cluster-like”
structure was generated with the <code><a href="../reference/graph_step.html">graph_step()</a></code> function. A
precision matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>
with non-null coefficients respecting the graph topology was produced
and then inverted to produce a covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">{\Sigma}</annotation></semantics></math>.
Semi-synthetic simulated datasets of sizes n=100, n=250, n=500, and
n=1000 samples were generated using gaussian copula from the covariance
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">{\Sigma}</annotation></semantics></math>
and the original count matrix to produce count tables that <em>(i)</em>
have the same marginal counts distributions as the original cohort
<em>(ii)</em> while enforcing the correlation between taxa encoded in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">{\Sigma}</annotation></semantics></math>.
The graph edges are here considered as true edges (ground truth).</p>
<p>On 10 different seeds, for each value of <code>prev_level</code>
tested (from 15% to 35%, by increment of 5%), and for each bacterial
species, the <code>cv.glmnet()</code> function was applied to each
simulated dataset (via the function
<code><a href="../reference/cvglm_to_coeffs_by_object.html">cvglm_to_coeffs_by_object()</a></code> from the
<code>NeighborFinder</code> package). This part corresponds to the first
steps of the method (see Figure 2, step 1 and step 2 at top). The
results were then filtered as in the procedure of
<code><a href="../reference/apply_NeighborFinder.html">apply_NeighborFinder()</a></code> (see Figure 2, step 2 at bottom) to
keep only a <code>filtering_top</code> percentage of the coefficients,
ranging from 5% to 30% in 5% increments, and 100% corresponding to not
filtering results. The final results were obtained by going through the
last step of the method (see Figure 2 step 3) with the selection of
interactions if they were detected in at least 5 of the 10 results (each
corresponding to a seed) for each pre-mentioned case.</p>
<p>Performance scores (F1) were calculated by comparing the true edges
of the graph with the detected neighbors, averaging on bacterial species
and cohort datasets. The same procedure was done on simulated datasets
of size n=50, but with a <code>prev_level</code> range from 30% to 60%
by increment of 5%.</p>
<p><img src="Technical_report_figures/heatmap_100-1000_appnote_NB.jpg" width="100%" style="display: block; margin: auto;"></p>
<center>
Figure 4: Performance scores on simulated data
</center>
<p><br></p>
<p>Based on the performance scores calculated on simulated data,
parameter pair choices (<code>prev_level</code> and
<code>filtering_top</code>) should be adjusted according to the size of
the dataset on which the user wishes to use NeighborFinder. When dealing
with large datasets, the user has plenty of parameter combinations that
lead to an equivalent expected performance, with the dark green areas
indicating a high F1 score (&gt;=0.9) in Figure 4. One choice could be
to select a low value of <code>prev_filter</code> to include as many
bacterial species as possible and then choose the
<code>filtering_top</code> value to ensure satisfactory optimum
performance. For example: with n=1000, <code>prev_level</code>=0.15 and
<code>filtering_top</code>=30. As the dataset size decreases, the user
is advised to increase the <code>prev_level</code> value while
maintaining a high value of <code>filtering_top</code>.</p>
<p><br></p>
<p>The function <code><a href="../reference/choose_params_values.html">choose_params_values()</a></code> has been designed to
allow the user to obtain a more specific indication based on the dataset
provided and the module of interest. This function works in the same way
as the procedure described previously:</p>
<ul>
<li><p>Generation of a graph</p></li>
<li><p>Simulation of a dataset respecting the dependencies between taxa
encoded in the graph, for different prevalence levels</p></li>
<li><p>Application of <code><a href="../reference/apply_NF_simple.html">apply_NF_simple()</a></code> on 10 seeds, with
and without filtering top results (testing different
percentages)</p></li>
<li><p>Application of the robustness step (filtering interactions if
they are found in at least half of the seeds-generated results)</p></li>
<li><p>Comparison and computation of F1 score:</p></li>
<li><p><em>before</em> (<code>filtering_top</code>=100 and no robustness
step)</p></li>
<li><p><em>after</em> the filtering &amp; robustness steps</p></li>
</ul>
<p>The user can then decide which values of these parameters to use for
downstream analysis and pass them on to
<code><a href="../reference/apply_NeighborFinder.html">apply_NeighborFinder()</a></code> using the arguments
<code>prev_level</code> and <code>filtering_top</code>.</p>
<p><br><br></p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Mathilde Sola, Mahendra Mariadassou, Magali Berland.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
