---
title: "NeighborFinder_flat.Rmd"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(glmnet)
# remotes::install_gitlab(repo = "metagenopolis/OneNet", host = "forgemia.inra.fr")
library(Matrix)
library(tidyverse)
library(tibble)
library(knitr)
library(igraph)
library(GGally)
library(network)
```

```{r description, eval=TRUE}
# Describe your package
fusen::fill_description(overwrite = TRUE,
  pkg = here::here(),
  fields = list(
    Title = "Find neighbor species of a bacteria of interest in the human gut microbiota",
    Description = "NeihborFinder uses the local approach to identify companion species of a bacteria of interest. From several abundance tables of metagenomic data, NeighborFinder suggests a shortlist of companion species based on the integration of results. A visualization via a network is proposed.",
    `Authors@R` = c(
      person("Mathilde", "Sola", email = "mathilde.sola@inrae.fr", role = c("aut", "cre"), comment = c())
    )
  )
)
# Define License with use_*_license()
usethis::use_mit_license("Mathilde Sola")

```

# Taxo data

```{r fun-taxo}
#' taxo
#'
#'#' @format A dataframe with 2537 msps (rows) and 4 columns:
#' \describe{
#'   \item{ msp_id }{  string }
#'   \item{ species }{  string }
#'   \item{ genus }{  string }
#'   \item{ catalogue }{  string indicating gut and/or oral }
#' }
#' @source https://entrepot.recherche.data.gouv.fr/dataset.xhtml?persistentId=doi:10.57745/7IVO3E
"taxo"
```

# Data for CRC patients

```{r fun-data}
#' data
#'
#'#' @format A list of dataframes corresponding to abundance tables merges with taxonomic information.
#' \describe{
#'   \item{ CRC_JPN }{  dataframe with only Japanese patients diagnosed with colorectal cancer }
#'   \item{ CRC_CHN }{  dataframe with only Chinese patients diagnosed with colorectal cancer }
#'   \item{ CRC_EUR }{  dataframe with only European patients diagnosed with colorectal cancer }
#'   \item{ CRC_JPN_CHN_EUR }{  dataframe with patients diagnosed with colorectal cancer from the 3 previous countries }
#' }
#' @source https://entrepot.recherche.data.gouv.fr/dataset.xhtml?persistentId=doi:10.57745/7IVO3E
"data"
```

# Metadata for CRC patients

```{r fun-metadata}
#' metadata
#'
#'#' @format A list of dataframes corresponding to metadata, giving more information on each patient.
#' \describe{
#'   \item{ CRC_JPN }{  dataframe with only Japanese patients diagnosed with colorectal cancer }
#'   \item{ CRC_CHN }{  dataframe with only Chinese patients diagnosed with colorectal cancer }
#'   \item{ CRC_EUR }{  dataframe with only European patients diagnosed with colorectal cancer }
#'   \item{ CRC_JPN_CHN_EUR }{  dataframe with patients diagnosed with colorectal cancer from the 3 previous countries }
#' }
#' @source https://entrepot.recherche.data.gouv.fr/dataset.xhtml?persistentId=doi:10.57745/7IVO3E
"metadata"
```

# Graphs for CRC patients

```{r fun-graphs}
#' graphs
#'
#'#' @format A list of dataframes corresponding to graphs based on synthetic data.
#' \describe{
#'   \item{ CRC_JPN }{  graph corresponding to data with only Japanese patients diagnosed with colorectal cancer }
#'   \item{ CRC_JPN_CHN_EUR }{  graph corresponding to data gathering Japanese, Chinese and European patients diagnosed with colorectal cancer }
#' }
"graphs"
```

# Pipe function

```{r fun-pipe}
#' Pipe operator
#'
#' See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.
#'
#' @name %>%
#' @rdname pipe
#' @keywords internal
#' @export
#' @importFrom magrittr %>%
#' @usage lhs \%>\% rhs
NULL
```

# Conversion to count table function with prevalence filter

```{r fun-get_count_table}
#' Conversion to count table function with prevalence filter (Extracted from OneNet package)
#' 
#' @param abund.path String. Path to the abundance table
#' @param abund.table Dataframe. Abundance table, it should have the bacterial species names as first column
#' @param sample.id String vector. IDs of samples to keep in the final table
#' @param prev.min Numeric. The value is between 0 and 1 and corresponds to the minimal prevalence threshold of bacterial species to keep in the final table
#' @param msp String vector. It indicates bacterial species names, if they are not specified in the abundance table first column
#' @param verbatim Boolean. Controls verbosity
#'
#' @return A list containing
#' \itemize{
#'  \item{data: }{the final count table (tibble)}
#'  \item{prevalences: }{a tibble gathering the prevalence of each bacterial species}
#'}
#' @export

get_count_table<-function(abund.path=NULL, abund.table=NULL, sample.id=NULL, prev.min, verbatim=TRUE, msp=NULL){
  if(!is.null(abund.path)){
    metaformat<-tail(strsplit(abund.path,"[.]")[[1]],1)
    if(metaformat=="rds"){ data_table <- as.matrix(readRDS(abund.path)) }
    else{ data_table <- as.matrix(read.delim(abund.path)) }
  }
 else{ data_table<-abund.table }
 
  if(is.null(msp)){
    species<-data_table[,1]
    data_table<-data_table[,-1]
  }
 else{ species<-msp }

  data_table<-apply(data_table,2,function(x){ as.numeric(x) })
  pct_zero_before=sum(data_table==0)/length(data_table)
  data_table<-tibble::as_tibble(data_table)

  if(!is.null(sample.id)){ data_table<-data_table[,colnames(data_table)%in%sample.id] }

  #Prevalence filtering
  counts<-data_table %>% dplyr::mutate(prev=rowMeans(.>0),msp=species) %>% dplyr::filter(prev>prev.min)
  prevs<-counts %>% dplyr::select(prev, msp)
  counts=counts %>% dplyr::select(-msp, -prev) %>% t(.)
  colnames(counts)<-prevs$msp
  #Set minimal positive value to 1
  cst=1/min(counts[counts!=0])
  counts=round(counts*cst)
  
  #Verbatim
  pct_zero_after=sum(counts==0)/length(counts)
  if(verbatim){cat(paste0("Preprocessing step output for species prevalence>",
                          prev.min*100,"% : \n   -from ", length(species),
                          " to ", ncol(counts)," species","\n   -from ",
                          round(pct_zero_before*100,1),"% to ",
                          round(pct_zero_after*100,1),"% zero values."))}

  return(list(data=counts, prevalences=prevs))
}
```

```{r ex-get_count_table}
tiny_data<-data.frame(msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))
# Applying a prevalence filter of 30% on the new count_table
count_table<-get_count_table(abund.table=tiny_data, sample.id=colnames(tiny_data), prev.min=0.3)
```

```{r test-module_to_node}
test_that("get_count_table works", {
  tiny_data<-data.frame(msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))
  expect_equal(get_count_table(abund.table=tiny_data, sample.id=colnames(tiny_data), prev.min=0.3, verbatim=FALSE)$prevalences$msp, c("msp_2","msp_3","msp_4"))
})
```

# Correspondence between the module ID (msp or functional module) and its name (bacteria or function)

```{r fun-module_to_node}
#' Correspondence between the module ID (msp or functional module) and its name (bacteria or function)
#' 
#' @param module String. The name of the biological object (msp or functional module), can be a single one or a list
#' @param annotation_table Dataframe. The dataframe gathering the taxonomic or functional module correspondence information 
#' @param col_module_id String. The name of the column with the module names in the annotation table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#'
#' @return Dictionary. The name of the module, can be a single one or a list
#' @export

module_to_node<-function (module, annotation_table, col_module_id = "msp_name", annotation_level){
    node_dict <- annotation_table %>% dplyr::select(all_of(col_module_id),
        !!rlang::sym(annotation_level)) %>% tibble::deframe()
    node_dict[module] %>% unname() %>% as.character()
}
```

```{r ex-module_to_node}
df_taxo<-data.frame(msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                    genus=c("A","B","C","D"),
                    species=c("A a","B a","C c","D b"))
# Correspondence for one specific msp
module_to_node("msp_1", annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="species")
# or for several msps
module_to_node(c("msp_1","msp_3","msp_4"), annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="species")
# and if one msp is repeated
module_to_node(c("msp_1","msp_1","msp_2"), annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="genus")
```

```{r test-module_to_node}
test_that("module_to_node works", {
  df_taxo<-data.frame(msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                    genus=c("A","B","C","D"),
                    species=c("A a","B a","C c","D b"))
  expect_equal(module_to_node("msp_1", annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="species"), "A a")
})
```

# List the modules corresponding to a given object of interest

```{r fun-identify_module}
#' List the modules corresponding to a given object of interest
#' 
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#' @param annotation_table Dataframe. The dataframe gathering the taxonomic or functional module correspondence information 
#' @param col_module_id String. The name of the column with the module names in the annotation table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1. Default value is set to the species level
#'
#' @return List of string. The module names of the corresponding object of interest
#' @export

identify_module <-function(object_of_interest, annotation_table, col_module_id, annotation_level = "species"){
  res<-annotation_table %>% 
    dplyr::filter(stringr::str_detect(!!rlang::sym(annotation_level), object_of_interest)) %>% 
    dplyr::pull(paste(col_module_id)) %>% 
    as.character()
  if (length(res)==0) {stop("ERROR: Please check spelling of object_of_interest :)")}
  else {res}
}
```

```{r ex-identify_module}
df_taxo<-data.frame(msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                    genus=c("One","One","One","Two"),
                    species=c("One bacteria","One bacterium L","One bacterium G","Two bact"))
identify_module(object_of_interest="bacterium", annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="species")
identify_module(object_of_interest="One", annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="species")
```

```{r test-identify_module}
test_that("identify_module works", {
  df_taxo<-data.frame(msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                    genus=c("One","One","One","Two"),
                    species=c("One bacteria","One bacterium L","One bacterium G","Two bact"))
  expect_equal(identify_module(object_of_interest="One", annotation_table=df_taxo, col_module_id = "msp_name", annotation_level="species"), c("msp_1", "msp_2", "msp_3"))
})
```

# Simulate data

```{r fun-simulate_from_ecdf}
#' Simulate data (extracted from OneNet package)
#' Generates synthetic count data based on empirical cumulative distribution (ecdf) of real count data
#'
#' @param real_data Matrix. Contains real count data of size n by p
#' @param Sigma Matrix. Covariance structure of size p by p
#' @param n Numeric. Number of samples
#' @param seed Numeric. Seed number for data generation
#' @param verbatim Boolean. If TRUE: iteration and index calculation for each step are printed out
#' 
#' @return Matrix. The vector from the upper triangular part of A.mat
#' @export

simulate_from_ecdf <- function (real_data, Sigma, n, seed=10010, verbatim=FALSE){
  p <- ncol(real_data)
  if (!is.null(seed)) { set.seed(seed) }
  mv_norm <- mvtnorm::rmvnorm(n, mean=rep(0, p), sigma=stats::cov2cor(Sigma))
  mv_unif <- stats::pnorm(mv_norm)
  ## Matrix of simulated counts
  sim_counts <- matrix(0, n, p)
  ## For each species, apply the inverse of the empirical distribution
  ## function to the uniform r.v.
  for (j in 1:p) {
    ## quantile(x, ., type = 1) is the inverse of the empirical distribution function of x
    sim_counts[, j] <- quantile(x=real_data[, j], probs=mv_unif[, j], names=FALSE, type=1)
  }
  sim_counts
}
```

# Create synthetic data from an empirical dataset

```{r fun-new_synth_data}
#' Simulate data from some empirical count dataset
#'
#' @param real_data Matrix. Empirical count table 
#' @param graph_type String. Structure type for the conditional dependency structure. Here only "cluster" was kept, see EMtree package for more options
#' @param graph Boolean. Optional graph to be used, must have rownames and colnames and reference all features from real_data
#' @param n Numeric. Number of samples to simulate
#' @param r Numeric. For cluster structure, controls the within/between ratio connection probability
#' @param dens Numeric. Graph density (for cluster graphs) or edges probability (for erdös-renyi graphs)
#' @param seed Numeric. Seed number for data generation (rmvnorm)
#' @param must_connect Boolean. TRUE to force the output graph to be connected
#' @param k Numeric. For cluster structure, number of groups
#' @param verbatim Boolean. Controls verbosity
#' @param signed Boolean. TRUE for simulating both positive and negative partial correlations. Default is to FALSE, which implies only negative partial correlations
#'
#' @return List. Containing the simulated discrete counts, the corresponding true partial correlation matrix from the latent Gaussian layer of the model and the original graph structure that was used
#' @export

new_synth_data<-function(real_data, graph_type="cluster", must_connect=TRUE, graph=NULL, n=300,
                         seed=10010, r=50, dens=4, k=3, verbatim=TRUE, signed=FALSE){
 p=ncol(real_data)
 species <- colnames(real_data)
 
 #Functions extracted from EMtree package to remove dependency
 ToSym<-function(A.vec){
  n <- (1 + sqrt(1 + 8*length(A.vec)))/2
  A.mat <- matrix(0, n, n)
  A.mat[upper.tri(A.mat)] <- A.vec
  A.mat <- A.mat + t(A.mat)
  A.mat
 }
 ToVec<-function(A.mat){ 
  return(suppressMessages(A.mat[upper.tri(A.mat)])) 
 }
 SimCluster<-function (p, k, dens, r){
  beta <- dens/(r/k + (k-1)/k)
  alpha <- r*beta
  while (alpha>1) {
   r <- 0.9*r
   beta <- dens/(r/k + (k-1)/k)
   alpha <- r*beta
  }
  Z <- t(stats::rmultinom(p, 1, rep(1/k, k)))
  groupe <- Z %*% 1:k
  Z <- Z %*% t(Z)
  diag(Z) <- 0
  ZZ <- ToVec(Z)
  G <- ToSym(rbinom(p*(p-1)/2, 1, alpha*ZZ + beta*(1-ZZ)))
  G
 }
 generator_graph<- function(p=20, graph="cluster", dens=0.3, r=2, k=3){
  theta <- matrix(0, p, p)
  if (graph=="cluster") { theta <- SimCluster(p, k=k, dens, r) }
  return(theta=Matrix::Matrix(theta, sparse=TRUE))
 }
 generator_param<-function(G, signed=FALSE, v=0.01){
  lambda <- 1
  p <- ncol(G)
  sumlignes <- rowSums(matrix(G, p, p))
  if (sum(sumlignes==0)!=0) 
   sumlignes[sumlignes==0] <- 0.1
  D <- diag(sumlignes + v)
  if (signed) {
   Gsign <- ToSym(ToVec(G*matrix(2*stats::rbinom(p^2, 1, 0.3)-1, p, p)))
   omega <- lambda*D + Gsign
   while (min(eigen(omega)$values)<1e-10 & lambda<1000) {
    lambda <- 1.1*lambda
    omega <- lambda*D+Gsign
   }}
  else {
   omega <- lambda*D+G
   while (min(eigen(omega)$values) < 1e-10) {
    lambda <- 1.1*lambda
    omega <- lambda*D+G
   }}
  sigma <- solve(omega)
  sim <- list(Sigma=sigma, Omega=omega, Lambda=lambda)
  sim
 }
 
 if (is.null(graph)) {
  if(!must_connect){
   set.seed(seed)
   G<-as.matrix(generator_graph(p=p, graph=graph_type, dens=dens/p,r,k))
  }else{
   i<-0; connect<-FALSE
   while(!connect){
    i<-i+1
    set.seed(i)
    G<-as.matrix(generator_graph(p=p, graph=graph_type, dens=dens/p,r,k))
    graph<-igraph::graph_from_adjacency_matrix (G)
    connect<-igraph::is_connected(graph)
   }
  }
 } else {
  if (!all(species %in% colnames(graph)) || !all(species %in% rownames(graph))) stop("Some species in the abundance dataset do not appear in the provided graph.")
  G <- graph[species, species]
 }
 dimnames(G) <- list(species, species)
 faithful_param<-generator_param(G=G, signed=signed)
 parcor<- -cov2cor(as.matrix(faithful_param$Omega))
 
 if(verbatim) cat("Simulation from real data ecdf...")
 
 simu_counts <- simulate_from_ecdf(real_data, Sigma=faithful_param$Sigma, n=n, seed=seed, verbatim=verbatim)
 simulated_data<-list(counts=simu_counts, par.cor=parcor, G=G)
 simulated_data
}
```

```{r ex-new_synth_data}
tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                      msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))

count_table<-get_count_table(abund.table=tiny_data %>% dplyr::select(-species), sample.id=colnames(tiny_data), prev.min=0.1)
tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species", seed=20242025) %>% suppressWarnings()
sim_data<-new_synth_data(count_table$data, n=50, graph=as.matrix(tiny_graph %>% dplyr::select(-species)), verbatim=FALSE, seed=20242025)
```

# Generate a graph

```{r fun-graph_step}
#' Generate a graph
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param col_module_id String. The name of the column with the module names in the annotation table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param seed Numeric. Seed number for data generation (new_synth_data)
#' @param data_type String. Enables the treatment of 16S data with "16S", default value is "shotgun"
#'
#' @return Dataframe. The dataframe is composed of 0 and 1 corresponding to the existence of edges on the graph.
#' @export

graph_step<-function(data_with_annotation, col_module_id, annotation_level, seed, data_type="shotgun"){
 if (data_type=="shotgun"){
 counts <- get_count_table(abund.table = data_with_annotation %>% dplyr::select(-!!rlang::sym(annotation_level)), sample.id=colnames(data_with_annotation), prev.min=0.15, verbatim=FALSE)$data
 }
 else if (data_type=="16S"){
   ## Compute prevalence of all modules at the studied level
   prev_df <- tibble::tibble(id_module=data_with_annotation %>% dplyr::pull(paste(col_module_id)),
                             prevalence=data_with_annotation %>% dplyr::select(-!!rlang::sym(annotation_level), -!!rlang::sym(col_module_id)) %>% 
                              data.matrix() %>% `>`(0) %>% rowMeans())
   prev_df_filtered <- prev_df %>% dplyr::filter(prevalence>0.15)
   data_with_annotation_filtered <- data_with_annotation %>% dplyr::filter(!!rlang::sym(col_module_id) %in% prev_df_filtered$id_module)
   counts <- data_with_annotation_filtered %>% dplyr::select(-!!rlang::sym(annotation_level), -!!rlang::sym(col_module_id)) %>% t() 
   colnames(counts) <- data_with_annotation_filtered %>% dplyr::pull(paste(col_module_id))
 }
 G <- new_synth_data(counts, n=50, verbatim=FALSE, seed=seed)$G
 dimnames(G) <- list(colnames(counts), colnames(counts))
 G <- G %>% as.data.frame() %>% 
  dplyr::mutate(!!rlang::sym(annotation_level):=module_to_node(rownames(G), annotation_table=data_with_annotation, col_module_id=col_module_id, annotation_level=annotation_level))
 G
}
```

```{r ex-graph_step}
tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                      msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))

tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species", seed=20242025) %>% suppressWarnings()
```

```{r test-graph_step}
test_that("graph_step works", {
  data(data)
  data(graphs)
  expect_equal(graph_step(data$CRC_JPN_CHN_EUR, col_module_id="msp_id", annotation_level="species", seed=10010), graphs$CRC_JPN_CHN_EUR)
})
```

# Modified central log ratio (mclr) transformation

```{r fun-mclr}
#' Modified central log ratio (mclr) transformation extracted from the SPRING package
#'
#' @param dat raw count data or compositional data (n by p) does not matter.
#' @param base exp(1) for natural log
#' @param tol tolerance for checking zeros
# For eps and atleast, users do not have to specify any values. Default should be enough.
#' @param eps epsilon in eq (2) of the paper "Yoon, Gaynanova, M\"{u}ller (2019), Frontiers in Genetics". positive shifts to all non-zero compositions. Refer to the paper for more details. eps = absolute value of minimum of log ratio counts plus c.
#' @param atleast default value is 1. Constant c which ensures all nonzero values to be strictly positive. default is 1.
#'
#' @return \code{mclr} returns a data matrix of the same dimension with input data matrix.
#' @export

mclr <- function(dat, base=exp(1), tol=1e-16, eps=NULL, atleast=1){
  dat <- as.matrix(dat)
  nzero <- (dat>=tol)  # index for nonzero part
  LOG <- ifelse(nzero, log(dat, base), 0.0) # take log for only nonzero values. zeros stay as zeros.

  # centralize by the log of "geometric mean of only nonzero part" # it should be calculated by each row.
  if (nrow(dat)>1){
    clrdat <- ifelse(nzero, LOG - rowMeans(LOG)/rowMeans(nzero), 0.0)
  } else if (nrow(dat)==1){
    clrdat <- ifelse(nzero, LOG - mean(LOG)/mean(nzero), 0.0)
  }

  if (is.null(eps)){
    if(atleast<0){
      warning("atleast should be positive. The functions uses default value 1 instead.")
      atleast=1
    }
    if( min(clrdat)<0 ){ # to find the smallest negative value and add 1 to shift all data larger than zero.
      positivecst <- abs(min(clrdat))+atleast # "atleast" has default 1.
    }else{
      positivecst <- 0
    }
    # positive shift
    ADDpos <- ifelse(nzero, clrdat+positivecst, 0.0) ## make all non-zero values strictly positive.
    return(ADDpos)
  } else if(eps==0){
    ## no shift. clr transform applied to non-zero proportions only. without pseudo count.
    return(clrdat)
  } else if(eps>0){
    ## use user-defined eps for additional positive shift.
    ADDpos <- ifelse(nzero, clrdat+eps, 0.0)
    return(ADDpos)
  } else {
    stop("check your eps value for additional positive shift. Otherwise, leave it as NULL.")
  }
}
```


# List the simulated count tables by level of prevalence

```{r fun-simulate_by_prevalence}
#' List the simulated count tables by level of prevalence
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param prev_list List of numeric. The prevalences to be studied. Required format is decimal: 0.20 for 20% of prevalence.
#' @param graph_file Dataframe. The object generated by graph_step() function
#' @param col_module_id String. The name of the column with the module names in data_with_annotation
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param sample_size Numeric. The size to be considerated, the value of 500 is recommended
#' @param seed Numeric. The seed number, ensuring reproducibility
#' @param verbatim Boolean. Controls verbosity
#' @param data_type String. Enables the treatment of 16S data with "16S", default value is "shotgun"
#'
#' @return List of dataframes. Each element of the list corresponds to a level of prevalence and is a simulated abundance table
#' @export

simulate_by_prevalence <- function(data_with_annotation, prev_list, graph_file=NULL, col_module_id, annotation_level, sample_size=500, seed, verbatim=FALSE, data_type="shotgun") {
  set.seed(seed)
  if (is.null(graph_file)) {stop("Please generate the graph beforehand with graph_step() function")}
  else {G <- graph_file}  
  if (verbatim) {cat("Generating simulated tables for each level of prevalence...\n")}
  
  abund_table <- data_with_annotation %>% dplyr::select(-all_of(col_module_id), -!!rlang::sym(annotation_level))
  modules <- data_with_annotation %>% dplyr::pull(col_module_id)
  sample_id <- abund_table %>% colnames()
  
  sim_one_prev <- function(prev) {
    if (verbatim) {cat(glue::glue("p{100*prev}"), sep = "\n")}
   if (data_type=="shotgun"){
    # Generating count table
    df_counts <- get_count_table(abund.table=abund_table, sample.id=sample_id, msp=modules, prev.min=prev, verbatim=FALSE)$data
   }
   else if (data_type=="16S"){
   prev_df <- tibble::tibble(id_module=modules,
                             prevalence=abund_table %>% data.matrix() %>% `>`(0) %>% rowMeans())
   prev_df_filtered <- prev_df %>% dplyr::filter(prevalence>0.15)
   data_with_annotation_filtered <- data_with_annotation %>% dplyr::filter(!!rlang::sym(col_module_id) %in% prev_df_filtered$id_module)
   df_counts <- data_with_annotation_filtered %>% dplyr::select(-!!rlang::sym(annotation_level), -!!rlang::sym(col_module_id)) %>% t() 
   colnames(df_counts) <- data_with_annotation_filtered %>% dplyr::pull(paste(col_module_id))
   }
    # Simulation of count table
    df_sim <- new_synth_data(df_counts, n=sample_size, graph=as.matrix(G %>% dplyr::select(-!!rlang::sym(annotation_level))), verbatim=FALSE, seed=seed)
    #Transformed matrix with mclr
    df_norm <- mclr(df_sim$counts)
    colnames(df_norm)<-colnames(df_counts)
    df_norm %>% as.matrix()
  }
  
  purrr::map(prev_list, sim_one_prev) %>% rlang::set_names(prev_list)
}
```

```{r ex-simulate_by_prevalence}
tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                      msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))

tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species", seed=20242025) %>% suppressWarnings()

tiny_sims<-simulate_by_prevalence(tiny_data, prev_list=c(0.20,0.30), graph_file=tiny_graph, col_module_id="msp_name", annotation_level="species", sample_size=500, seed=20242025)
```

```{r test-simulate_by_prevalence}
test_that("simulate_by_prevalence works", {
  tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                        msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                        SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                        SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                        SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                        SAMPLE4=c(0,0,2.98320e-05,0))
  tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species",seed=20242025) %>% suppressWarnings()
  computed_sims <- simulate_by_prevalence(tiny_data, prev_list=c(0.20), graph_file=tiny_graph, col_module_id="msp_name", annotation_level="species", sample_size=2, seed=20242025)
  
  expected_sims <- list(`0.2` = structure(c(0, 0, 0, 0, 1.48023097509365, 1.96046195018729, 0, 1), .Dim = c(2L, 4L), 
                                          .Dimnames = list(NULL, c("msp_1", "msp_2", "msp_3", "msp_4"))))
  expect_equal(computed_sims, expected_sims)
})
```

# Extract edges in graph involving any module in object_of_interest set

```{r fun-prev_for_selected_nodes}
#' Extract edges in graph involving any module in object_of_interest set
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param graph_file Dataframe. The object generated by graph_step() function
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#'
#' @return Dataframe. The dataframe of edges in the graph involving modules corresponding to object_of_interest and their corresponding prevalences.
#' @export

prev_for_selected_nodes <- function(data_with_annotation, graph_file, col_module_id, annotation_level, object_of_interest=NULL) {
  if (is.null(graph_file)) {stop("Please generate the graph beforehand with graph_step() function")}
  else {G <- graph_file} 
  
  ## Compute prevalence of all modules at the studied level
  prev_df <- tibble::tibble(id_module = data_with_annotation %>% dplyr::pull(paste(col_module_id)),
                    prev = data_with_annotation %>% dplyr::select(-!!rlang::sym(annotation_level), -all_of(col_module_id)) %>% data.matrix() %>% `>`(0) %>% rowMeans())
  
  ## Extract edges starting or ending from the object of interest
  if (is.null(object_of_interest)) {object_index <- seq_along(G %>% dplyr::pull(!!rlang::sym(annotation_level)))} 
  else {object_index <- G %>% dplyr::pull(!!rlang::sym(annotation_level)) %>% stringr::str_detect(paste(object_of_interest))}
  
  G_object <- G[object_index, ] %>% dplyr::select(-!!rlang::sym(annotation_level)) 
  
  if (!nrow(G_object)){return(tibble::tibble())}
  
  truth <- G_object[, colSums(G_object) != 0] %>% tibble::as_tibble(rownames = "node1") %>% 
    tidyr::pivot_longer(-node1, values_to = "Edge", names_to = "node2") %>% 
    dplyr::select(order(colnames(.))) %>% 
    dplyr::filter(Edge!=0) %>% dplyr::select(-Edge) 
  ## Add prevalences for node1 and node2
  truth <- truth %>% 
    dplyr::left_join(prev_df, by = dplyr::join_by(node1 == id_module)) %>% 
    ## and rename prev with suffix matching corresponding module
    dplyr::left_join(prev_df, by = dplyr::join_by(node2 == id_module), suffix = c("1", "2"))
  truth
}
```

```{r ex-prev_for_selected_nodes}
tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                      msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))
tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species", seed=20242025) %>% suppressWarnings()

tiny_truth <-prev_for_selected_nodes(tiny_data, tiny_graph, col_module_id="msp_name", annotation_level="species", object_of_interest="bacterium")
```

```{r test-prev_for_selected_nodes}
test_that("prev_for_selected_nodes works", {
  tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                        msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                        SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                        SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                        SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                        SAMPLE4=c(0,0,2.98320e-05,0))
  tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species",seed=20242025) %>% suppressWarnings()
  
  expected_truth <- tibble::tibble(node1=c("msp_2","msp_2","msp_2","msp_3","msp_3"),
                                   node2=c("msp_1","msp_3","msp_4","msp_2","msp_4"),
                                   prev1=c(0.5,0.5,0.5,0.75,0.75),
                                   prev2=c(0.25,0.75,0.5,0.5,0.5))
  expect_equal(prev_for_selected_nodes(tiny_data, tiny_graph, col_module_id="msp_name", annotation_level="species", object_of_interest="bacterium"), expected_truth)
})
```

# Give true neighbors by level of prevalence

```{r fun-truth_by_prevalence}
#' Give true neighbors by level of prevalence
#' 
#' @param edge_table Dataframe. The result of prev_for_selected_nodes()
#' @param prev_list List of numeric. The prevalences to be studied. Required format is decimal: 0.20 for 20% of prevalence
#'
#' @return List of dataframes. Each element of the list corresponds to a dataframe of true edges by level of prevalence
#' @export

truth_by_prevalence <- function(edge_table, prev_list) {
  
  for_one_prev<-function(prev) {
    edge_table %>% dplyr::filter(prev1 >= prev, prev2 >= prev)
  } 
  cat("Defining and saving true neighbors...\n")
  purrr::map(prev_list, for_one_prev) %>% rlang::set_names(prev_list)
}  
```

```{r ex-truth_by_prevalence}
tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                      msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))

tiny_graph<-graph_step(tiny_data, col_module_id="msp_name", annotation_level="species", seed=20242025) %>% suppressWarnings()

tiny_truth <-prev_for_selected_nodes(tiny_data, tiny_graph, col_module_id="msp_name", annotation_level="species", object_of_interest="bacterium")

tiny_true_edges<-truth_by_prevalence(tiny_truth, c(0.20,0.30))
```

```{r test-truth_by_prevalence}
test_that("truth_by_prevalence works", {
  tiny_truth <-tibble::tibble(node1=c("msp_2","msp_2","msp_2","msp_3","msp_3"),
                              node2=c("msp_1","msp_3","msp_4","msp_2","msp_4"),
                              prev1=c(0.5,0.5,0.5,0.75,0.75),
                              prev2=c(0.25,0.75,0.5,0.5,0.5))
  
  expected_true_edges0.3 <- tibble::tibble(node1=c("msp_2", "msp_2", "msp_3", "msp_3"),
                                           node2=c("msp_3","msp_4","msp_2","msp_4"),
                                           prev1=c(0.5,0.5,0.75,0.75),
                                           prev2=c(0.75,0.5,0.5,0.5))
  expect_equal(truth_by_prevalence(tiny_truth, c(0.30))[[1]], expected_true_edges0.3)
})
```

# Normalize data and filter it by prevalence level

```{r fun-norm_data}
#' Normalize data and filters it by prevalence level
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param prev_list Vector of numeric. The prevalences to be studied. Required format is decimal: 0.20 for 20% of prevalence
#' @param data_type String. Enables the treatment of 16S data with "16S", default value is "shotgun"
#' @param annotation_level String. Annotation level to aggregate the taxa
#' 
#' @return List of dataframes. Each element of the list corresponds to a normalized 'data_with_annotation', by level of prevalence
#' @export

norm_data<-function(data_with_annotation, col_module_id, prev_list=c(0.30), annotation_level, data_type="shotgun"){
 list_norm <- list()
 res <- tibble::tibble()
 #Normalizing for each level of prevalence if prev_list is a vector
 # cat("Normalizing data...\n")
 for (prev in prev_list){
  
  if (data_type=="shotgun"){
   #Creating count table
   df_counts <- get_count_table(abund.table=data_with_annotation[,-1], sample.id=colnames(data_with_annotation), prev.min=prev, verbatim=FALSE)
   #Transformed matrix with mclr
   df_norm <- mclr(df_counts$data)
   colnames(df_norm) <- colnames(df_counts$data) 
  }
  
  # Alternative if the input data is recovered from 16S sequencing
  else if (data_type=="16S"){
   ## Compute prevalence of all modules at the studied level
   prev_df <- tibble::tibble(id_module=data_with_annotation %>% dplyr::pull(paste(col_module_id)),
                             prevalence=data_with_annotation %>% dplyr::select(-!!rlang::sym(annotation_level), -!!rlang::sym(col_module_id)) %>% 
                              data.matrix() %>% `>`(0) %>% rowMeans())
   prev_df_filtered <- prev_df %>% dplyr::filter(prevalence>prev)
   data_with_annotation_filtered <- data_with_annotation %>% dplyr::filter(!!rlang::sym(col_module_id) %in% prev_df_filtered$id_module)
   #Arranging data
   df <- data_with_annotation_filtered %>% dplyr::select(-!!rlang::sym(annotation_level), -!!rlang::sym(col_module_id)) %>% t() 
   colnames(df) <- data_with_annotation_filtered %>% dplyr::pull(paste(col_module_id))
   #Transformed matrix with mclr
   df_norm <- mclr(df)
   colnames(df_norm) <- colnames(df) 
  }
  
  df_norm <- df_norm %>% as.matrix()
  list_norm[[paste(prev)]] <- df_norm
 }
 return(list_norm)
}
```

```{r ex-norm_data}
tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                      msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                      SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                      SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                      SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                      SAMPLE4=c(0,0,2.98320e-05,0))

tiny_normed <-norm_data(tiny_data, col_module_id="msp_name", annotation_level="species", prev_list=c(0.20, 0.30))
```

```{r test-norm_data}
test_that("norm_data works", {
  tiny_data<-data.frame(species=c("One bacteria","One bacterium L","One bacterium G","Two bact"),
                        msp_name=c("msp_1","msp_2","msp_3","msp_4"),
                        SAMPLE1=c(0,1.328425e-06,0,1.527688e-07),
                        SAMPLE2=c(1.251707e-07,1.251707e-07,3.985320e-07,0),
                        SAMPLE3=c(0,0,4.926046e-09,5.626392e-06),
                        SAMPLE4=c(0,0,2.98320e-05,0))
  
  expected_normed0.2 <-data.frame(msp_1=c(0.00000,4.12841,0.00000,0.00000),
                                  msp_2=c(5.602486,4.128410,0.000000,0.000000),
                                  msp_3=c(0.000000,5.303984,1.000000,4.520268),
                                  msp_4=c(3.438051,0.000000,8.040536,0.000000))  
  rownames(expected_normed0.2)<-c("SAMPLE1","SAMPLE2","SAMPLE3","SAMPLE4")
  expect_equal(norm_data(tiny_data, col_module_id="msp_name",annotation_level="species", prev_list=c(0.20))[[1]] %>% as.data.frame() %>% round(digits=5), expected_normed0.2 %>% round(digits=5))
})
```

# Apply cv.glmnet() for a given module ID

```{r fun-find_module_neighbors}
#' Apply cv.glmnet() for a given mmodule ID
#' 
#' @param df Dataframe. A normalized dataframe
#' @param module String. The module ID name
#' @param seed Numeric. The seed number, ensuring reproducibility
#' @param covar String or formula. Formula or the name of the column of the covariate in the metadata table. Note that "study_accession" is equivalent to ~study_accession
#' @param meta_df Dataframe. The dataframe giving metadata information
#' @param sample_col String. The name of the column in metadata indicating the sample names, it should be consistent with the colnames of 'df'
#' 
#' @return Dataframe. Returns the module ID, its detected neighbor and the corresponding coefficient 
#' @export

find_module_neighbors <- function(df, module, seed = NULL, covar = NULL, meta_df = NULL, sample_col = NULL) {
  if (is.null(seed)) {
    stop("No seed provided, make sure you've set and recorded the random seed of your session for reproducibility")
  } 
  else {set.seed(seed)}
  ## Build default penalty factor (in the absence of covariates)
  penalty_factor <- rep(1, ncol(df))
  penalized_features <- colnames(df)
  if (!is.null(covar)) {
    ## Stop if no metadata provided
    if (is.null(meta_df)) stop("Please provide a metadata table.") 
    ## Stop if no sample column provided
    if (is.null(sample_col)) stop("Please indicate the column of sample names in metadata.") 
    ## Process metadata to match abundance table
    if (!is.null(sample_col) && sample_col %in% colnames(meta_df)) {
      rownames(meta_df) <- meta_df[[sample_col]]
    }
    if (! all(rownames(df) %in% rownames(meta_df))) {
      stop("Some samples are missing from the metadata table.")
    }
    ## process formula to build covariate matrix
    if (!rlang::is_formula(covar)) {
      covar <- as.formula(paste("~", paste(covar, collapse = "+")))
    }
    meta_df <- meta_df[rownames(df), ]
    covariates <- model.matrix(covar, meta_df)
    covariates <- covariates[, !colnames(covariates) == "(Intersect)", drop = FALSE]
    if (nrow(covariates) < nrow(df)) {
      stop("Some samples were dropped, likely because of missing data in the covariates.")
    }
    p_covar <- ncol(covariates)
    df <- cbind(df, covariates)
    penalty_factor <- c(penalty_factor, rep(0, p_covar))
  }
  
  col <- which(module == colnames(df))
  if (!length(col)) {return(tibble::tibble(.rows = 0))}
  res_glm <- glmnet::cv.glmnet(df[,-col], df[,col], penalty.factor = penalty_factor[-col]) %>% coef(s = "lambda.min")
  tibble::tibble(node1 = module, node2 = rownames(res_glm), coef = as.numeric(res_glm)) %>%
   dplyr::filter(coef!=0, node2 %in% penalized_features) 
}
```

```{r ex-find_module_neighbors}
data(data)
data(metadata)
#Simple example
x <- norm_data(data$CRC_JPN, 0.30)[[1]]
neighbors_JPN<-find_module_neighbors(df=x, module="msp_0030", seed=20242025)
#Example with covariate
x <- norm_data(data$CRC_CHN, 0.30)[[1]]
neighbors_CHN<-find_module_neighbors(df=x, module="msp_0030", seed=20242025, covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")
```

# Apply cv.glmnet() for a list of module IDs

```{r fun-find_all_module_neighbors}
#' Apply cv.glmnet() for a list of module IDs
#' 
#' @param df Dataframe. A normalized dataframe
#' @param test_module List of string. The module IDs 
#' @param seed Numeric. The seed number, ensuring reproducibility
# @param covar String or formula. Formula or the name of the column of the covariate in the metadata table. Note that "study_accession" is equivalent to ~study_accession
# @param meta_df Dataframe. The dataframe giving metadata information
# @param sample_col String. The name of the column in metadata indicating the sample names, it should be consistent with the colnames of 'df'
#' @param ... Additional arguments passed on to [find_module_neighbors()]
#' 
#' @return Dataframe. Returns the module ID, its detected neighbor and the corresponding coefficient 
#' @export

find_all_module_neighbors <- function(df, test_module, seed=NULL, ...) {
  purrr::map(test_module, function(x) find_module_neighbors(df, x, seed, ...)) %>% dplyr::bind_rows()
}
```

```{r ex-find_all_module_neighbors}
data(data)
data(metadata)
#Simple example
x <- norm_data(data$CRC_JPN, 0.30, annotation_level="species")[[1]]
neighbors_JPN<-find_all_module_neighbors(df=x, test_module=c("msp_0030","msp_0345"), seed=20242025)
# Example with covariate
x <- norm_data(data$CRC_CHN, 0.30, annotation_level="species")[[1]]
neighbors_CHN<-find_all_module_neighbors(df=x, test_module=c("msp_0030","msp_0345"), seed=20242025, covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")
```

# Apply cv.glmnet() for a list of module IDs and for each prevalence level

```{r fun-cvglm_to_coeffs_by_object}
#' Apply cv.glmnet() for a list of module IDs and for each prevalence level
#' 
#' @param list_dfs List of dataframe. A normalized dataframe
#' @param test_module List of string. The module IDs
#' @param seed Numeric. The seed number, ensuring reproducibility
# @param covar String or formula. Formula or the name of the column of the covariate in the metadata table. Note that "study_accession" is equivalent to ~study_accession
# @param meta_df Dataframe. The dataframe giving metadata information
# @param sample_col String. The name of the column in metadata indicating the sample names, it should be consistent with the colnames of 'df'
#' @param ... Additional arguments passed on to [find_all_module_neighbors()]
#' 
#' @return Dataframe. Returns the module ID, its detected neighbor and the corresponding coefficient 
#' @export

cvglm_to_coeffs_by_object<-function(list_dfs, test_module = identify_module(), seed=NULL, ...){
  # cat("Applying NeighborFinder to detect neighbors...\n")
  purrr::map(list_dfs, function(df) find_all_module_neighbors(df, test_module, seed, ...)) %>% 
    dplyr::bind_rows(.id = "prev_level")
}
```

```{r ex-cvglm_to_coeffs_by_object}
data(data)
data(metadata)
#Simple example
normed_JPN <-norm_data(data$CRC_JPN, col_module_id="msp_id", annotation_level="species", prev_list=c(0.20, 0.25, 0.30))
neighbors_JPN<-cvglm_to_coeffs_by_object(list_dfs=normed_JPN, test_module=c("msp_0030","msp_0345"), seed=20242025)
#Example with covariate
normed_CHN <-norm_data(data$CRC_CHN, col_module_id="msp_id", annotation_level="species", prev_list=c(0.20, 0.25, 0.30))
neighbors_CHN<-cvglm_to_coeffs_by_object(list_dfs=normed_CHN, test_module=c("msp_0030","msp_0345"), seed=20242025, covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")
```

# Gather lists of neighbors of true ones from the graph and detected ones from cv.glmnet()

```{r fun-final_step}
#' Gather lists of neighbors of true ones from the graph and detected ones from cv.glmnet()
#' 
#' @param df_truth Dataframe. The one resulting from truth_by_prevalence()
#' @param df_glm Dataframe. The one resulting from cvglm_to_coeffs_by_object()
#' @param robustness_step Boolean. When TRUE, filtering_top will be different from 100%, when FALSE the reults from the naïve method are looked at
#' 
#' @return Dataframe. Returns for each level of prevalence and module ID, the list of true and/or detected neighbors and the corresponding list of coefficients 
#' @export

final_step<-function(df_truth, df_glm, robustness_step=NULL){
 truth <- df_truth %>% dplyr::bind_rows(.id = "prev_level") %>% 
   dplyr::mutate(prev_level=as.numeric(prev_level)) %>% 
  dplyr::summarize(node2_true = list(node2), .by = c(prev_level, node1))
 
 if (robustness_step!=TRUE){
  inference <- df_glm %>% dplyr::bind_rows(.id = "prev_level") %>% dplyr::filter(filtering_top==100) %>% 
   dplyr::mutate(prev_level=as.numeric(prev_level)) %>% 
   dplyr::summarize(node2_detected = list(node2), 
                    node2_coef     = list(coef), 
                    .by = c(prev_level, node1))
  
  result<-dplyr::full_join(truth, inference, by = c("prev_level", "node1")) %>% 
   lapply(., function(col) ifelse(sapply(col, is.null), 0, col)) %>% do.call(cbind, .) %>% 
   tibble::as_tibble()
 }
 
 else if (robustness_step==TRUE){
  inference <- df_glm %>% dplyr::bind_rows(.id = "prev_level") %>% dplyr::filter(., filtering_top!=100) %>% 
   dplyr::mutate(prev_level=as.numeric(prev_level))
  res<-c()
  for (prev in unique(inference$prev_level)){
   for (top in unique(inference$filtering_top)){
    df<-inference %>% dplyr::filter(prev_level==prev & filtering_top==top) %>% 
     dplyr::mutate(pair=paste(node1,node2,sep="_")) %>% dplyr::group_by(pair) %>% unique() %>% 
     dplyr::summarize(seeds_detect=dplyr::n(), med=median(coef)) %>% dplyr::filter(seeds_detect>=5) %>% dplyr::select(-seeds_detect) %>%
     unique() %>% dplyr::ungroup() %>% tidyr::separate(pair, into = c("node1", "node2"), sep="_msp") %>%
     dplyr::mutate(node2=paste0("msp",node2)) %>% dplyr::rename(coef=med) %>% 
     dplyr::mutate(prev_level=prev, filtering_top=top)
    if (!nrow(df)){
     df<-inference %>% dplyr::filter(prev_level==prev, filtering_top==top) %>% 
      dplyr::slice_head(n=1) %>% dplyr::mutate(node2=0, coef=0) %>% dplyr::select(-SEED)
     }
    res<-rbind(res,df)
   }
  } 
  inference_robust<-res %>% dplyr::summarize(node2_detected = list(node2), 
                                             node2_coef     = list(coef), 
                                             .by = c(prev_level, filtering_top, node1))
  
  result<-dplyr::full_join(truth, inference_robust, by = c("prev_level", "node1")) %>% 
   lapply(., function(col) ifelse(sapply(col, is.null), 0, col)) %>% do.call(cbind, .) %>% 
   tibble::as_tibble()
 }
 result
}
```

```{r ex-final_step}
#Dataframe with true neighbors
df_true<-list(tibble::tibble(node1=c("msp_1","msp_1","msp_2","msp_3"), node2=c("msp_55","msp_20","msp_3","msp_18"),
                             prev1=c(0.28,0.28,0.96,0.75), prev2=c(0.76,0.25,0.75,0.60)),
              tibble::tibble(node1=c("msp_2","msp_3"), node2=c("msp_3","msp_18"), prev1=c(0.96,0.75), prev2=c(0.75,0.60))) %>% rlang::set_names(c("0.20","0.30"))

#Dataframe with detected neighbors
df_detected<-list(tibble::tibble(prev_level=c("0.20","0.30","0.30","0.30"), node1=c("msp_2","msp_2","msp_3","msp_3"),
                            node2=c("msp_3","msp_3","msp_18","msp_8"), coef=c(0.406,-0.025,0.160,0.005), 
                            filtering_top=c(100,100,100,100)),
                  tibble::tibble()) %>% rlang::set_names(c("0.20","0.30"))
#Use final_step() to gather both
neighbors<-final_step(df_true, df_detected, robustness_step=FALSE)
```

# Compute precision rate

```{r fun-compute_precision}
#' Compute precision rate
#' 
#' @param true List. The one of true neighbors
#' @param detected List. The one of detected neighbors
#' 
#' @return Numeric. Returns the precision rate
#' @export

compute_precision <- function(true, detected) {
  if (length(detected) == 0) return(0)
  ## TP / (TP + FP)
  length(intersect(true, detected)) / length(detected)
}
```

```{r ex-compute_precision}
compute_precision(c("a"), c("a", "b", "c"))
compute_precision(c("a","b"), c("a", "c"))
```

```{r test-compute_precision}
test_that("compute_precision works", {c(
  expect_equal(compute_precision(c("a"), c("a", "b", "c")), 1/3),
  expect_equal(compute_precision(c("a","b"), c("a", "c")), 0.50))
})
```

# Compute recall rate

```{r fun-compute_recall}
#' Compute recall rate
#' 
#' @param true List. The one of true neighbors
#' @param detected List. The one of detected neighbors
#' 
#' @return Numeric. Returns the recall rate
#' @export

compute_recall <- function(true, detected) {
  if (length(true) == 0) return(0)
  ## TP / (TP + FN)
  length(intersect(true, detected)) / length(true)
}
```

```{r ex-compute_recall}
compute_recall(c("a"), c("a", "b", "c"))
compute_recall(c("a","b"), c("a", "c"))
```

```{r test-compute_recall}
test_that("compute_recall works", {c(
  expect_equal(compute_recall(c("a"), c("a", "b", "c")), 1),
  expect_equal(compute_recall(c("a","b"), c("a", "c")), 0.50))
})
```

# Render a table gathering precision and recall rates before and after a modicifation

```{r fun-test_filter}
#' Render a table gathering precision and recall rates before and after filtering on coefficient values
#' 
#' @param df_before Dataframe. The one of true neighbors
#' @param df_after Dataframe. The one of detected neighbors
#' @param prevs List of numeric. The prevalences to be studied. Required format is decimal: 0.20 for 20% of prevalence
#' 
#' @return Dataframe. Returns the precision and recall rates before and after the modification
#' @export

test_filter<-function(df_before, df_after, prevs=NULL){
  scores_before <- df_before %>%  dplyr::mutate(
    precision_before = purrr::pmap_dbl(list(node2_true, node2_detected), compute_precision),
    recall_before = purrr::pmap_dbl(list(node2_true, node2_detected), compute_recall))
  scores_after <- df_after %>%  dplyr::mutate(
    precision_after  = purrr::pmap_dbl(list(node2_true, node2_detected), compute_precision),
    recall_after = purrr::pmap_dbl(list(node2_true, node2_detected), compute_recall))
  
  if(!nrow(scores_before) | !nrow(scores_after)){ return(tibble::tibble()) }
  else{
  score_table <- dplyr::full_join(scores_before, scores_after, by=c("prev_level","node1")) %>% 
     dplyr::select(prev_level, filtering_top, precision_before, recall_before, precision_after, recall_after) %>% 
     dplyr::mutate_all(~ replace(., is.na(.), 0))
  
  res <- score_table %>%  #dplyr::summarize(across(precision_before:recall_after, mean), .by = c(prev_level,filtering_top)) %>%
   as.data.frame()
  if (is.null(prevs)) {return(res)}
  else {return(res %>% dplyr::filter(prev_level %in% prevs))}
  }
}
```

```{r ex-test_filter}
#Dataframe with true neighbors
list_true<-list(tibble::tibble(node1=c("msp_1","msp_1","msp_2","msp_3"), node2=c("msp_55","msp_20","msp_3","msp_18"),
                             prev1=c(0.28,0.28,0.96,0.75), prev2=c(0.76,0.25,0.75,0.60)),
              tibble::tibble(node1=c("msp_2","msp_3"), node2=c("msp_3","msp_18"), prev1=c(0.96,0.75), prev2=c(0.75,0.60))) %>% rlang::set_names(c("0.20","0.30"))

#Dataframes with detected neighbors
list_detected<-list(tibble::tibble(prev_level=c("0.20","0.30","0.30","0.30"), node1=c("msp_2","msp_2","msp_3","msp_3"),
                            node2=c("msp_3","msp_3","msp_18","msp_8"), coef=c(0.406,-0.025,0.160,0.005), 
                            filtering_top=c(100,100,100,100)),
                  tibble::tibble()) %>% rlang::set_names(c("0.20","0.30"))
list_detected2<-list(tibble::tibble(prev_level=c("0.20","0.20"), node1=c("msp_2","msp_3"),
                            node2=c("msp_3","msp_18"), coef=c(0.160,0.005), 
                            filtering_top=c(100,100)),
                  tibble::tibble()) %>% rlang::set_names(c("0.20","0.30"))
#Use final_step() to gather both
neighbors<-final_step(list_true, list_detected, robustness_step=FALSE) 
neighbors2<-final_step(list_true, list_detected2, robustness_step=FALSE) %>% dplyr::mutate(filtering_top=10)
#Calculate scores
scores<-test_filter(neighbors, neighbors2)
```

# Render a table to give an indication of the values to choose for the prevalence level and the top filtering percentage

```{r fun-choose_params_values}
#' Render a table to give an indication of the values to choose for the prevalence level and the top filtering percentage
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
# @param list_sims List of dataframes. The result of simulate_by_prevalence()
#' @param prev_list List of numeric. The prevalences to be studied. Required format is decimal: 0.20 for 20% of prevalence
#' @param sample_size Numeric. Number of samples in each dataset.
#' @param filtering_list List of numeric. The filtering top percentages to be studied. Required format is: 10 for the top 10% 
#' @param graph_file Dataframe. The object generated by graph_step() function
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#'  
#' @return Dataframe. Returns F1 rates before and after using NeighborFinder()
#' @export

choose_params_values <- function(data_with_annotation, object_of_interest, sample_size, prev_list=c(0.2,0.3,0.4), filtering_list=c(10,20,30), graph_file=NULL, col_module_id, annotation_level){
 
 #Loading graph
 if (is.null(graph_file)) {stop("Please generate the graph beforehand with graph_step() function")}
 else {G <- graph_file}
 
 # Extract edge_prevalence table for species of interest
 true_edges <- prev_for_selected_nodes(data_with_annotation, graph_file, col_module_id, annotation_level, object_of_interest)
 if(!nrow(true_edges)){return(tibble::tibble())}
 
 list_truth <- truth_by_prevalence(true_edges, prev_list)
 
 #Applying  cv.glmnet on 10 seeds
 set.seed(seed=123)
 seeds10<-sample(1:1000000,10)
 res_glm<-c()
 for (seed in seeds10){
  sims<-simulate_by_prevalence(data_with_annotation, prev_list=prev_list, graph_file=graph_file, col_module_id=col_module_id,
                               annotation_level="species", seed=seed, sample_size=sample_size) 
  df_glm<-cvglm_to_coeffs_by_object(sims, 
                                    test_module=identify_module(object_of_interest=object_of_interest,
                                                                annotation_table=data_with_annotation, 
                                                                col_module_id=col_module_id, annotation_level=annotation_level),
                                    seed=seed) %>% dplyr::mutate(SEED=seed)
  if(!nrow(df_glm)){return(tibble::tibble())}
  else{
   filtering_list<-c(filtering_list,100)
   res<-purrr::map_dfr(filtering_list,  ~ df_glm %>% dplyr::filter(abs(coef)>quantile(abs(coef), 1-.x/100)) %>% dplyr::mutate(filtering_top=.x))
  }
  if(!nrow(res)){res<-tibble::tibble()}
  res_glm<-rbind(res_glm, res)
 }
 list_glm<-split(res_glm, res_glm$prev_level)
 
 #Filtering results & rendering table
 cat("Calculating scores...\n")
 before<-final_step(list_truth, list_glm, robustness_step=FALSE) #naïve method with scores calculated on 10 seeds, with filtering_top=100%
 after<-final_step(list_truth, list_glm, robustness_step=TRUE) #full method with a value of filtering_top + the robustness part (selection of neighbors if they were found at least 5 out of 10 times)
 
 harm_mean<-function(P,R){
  hm<-2*(P*R)/(P+R)
  hm
 }
 res<-test_filter(before, after, prev_list) %>% 
  dplyr::mutate(F1_before=harm_mean(precision_before, recall_before) %>% signif(.,2)) %>% 
  dplyr::mutate(F1_after=harm_mean(precision_after, recall_after) %>% signif(.,2)) %>% 
  dplyr::select(-precision_before,-recall_before,-precision_after,-recall_after)
 res$F1_before[is.na(res$F1_before)] <- 0
 res$F1_after[is.na(res$F1_after)] <- 0
 
 if (!nrow(res)){return(tibble::tibble())}
 else{res %>% dplyr::mutate(prev_level=as.numeric(prev_level))}
}
```

```{r ex-choose_params_values}
data(data)
data(graphs)
choose_params_values(data_with_annotation=data$CRC_JPN, object_of_interest="Escherichia coli", sample_size=100, prev_list=c(0.20,0.30), filtering_list=c(10,20), graph_file=graphs$CRC_JPN, col_module_id="msp_id", annotation_level="species")
```


```{r test-choose_params_values}
test_that("choose_params_values works", {
 data(data)
data(graphs)
scores<-choose_params_values(data_with_annotation=data$CRC_JPN, object_of_interest="Escherichia coli", sample_size=100, prev_list=c(0.20,0.30), filtering_list=c(10,20), graph_file=graphs$CRC_JPN, col_module_id="msp_id", annotation_level="species")
  expect_equal(scores$F1_after,c(0.00,0.67,0.67,1.00))
})
```

# Apply NeighborFinder simplest version on raw data

```{r fun-apply_NF_simple}
#' Apply NeighborFinder simplest version on raw data
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param prev_level Numeric. The prevalence to be studied. Required format is decimal: 0.20 for 20% of prevalence
#' @param filtering_top Numeric. The filtering top percentage to be studied. Required format is: 10 for top 10% 
#' @param seed Numeric. The seed number, ensuring reproducibility
#' @param ... Additional arguments passed on to [cvglm_to_coeffs_by_object()]

# @param covar String or formula. Formula or the name of the column of the covariate in the metadata table. Note that "study_accession" is equivalent to ~study_accession
# @param meta_df Dataframe. The dataframe giving metadata information
# @param sample_col String. The name of the column in metadata indicating the sample names, it should be consistent with the colnames of 'df'
#' 
#' @return Dataframe. Returns results after using NeighborFinder(): for each module ID from 'object_of_interest', the names of their neighbors and the corresponding coefficients calculated by cv.glmnet()
#' @export

apply_NF_simple<-function(data_with_annotation, object_of_interest, col_module_id, annotation_level, prev_level=0.30, filtering_top=20, seed=NULL, ...){
  if (is.null(seed)) {stop("No seed provided, make sure you've set and recorded the random seed of your session for reproducibility")} 
  #Normalize data
  normed_data <- norm_data(data_with_annotation=data_with_annotation, col_module_id=col_module_id, prev_list=c(prev_level), annotation_level=annotation_level)
  #Find neighbors with cv.glmnet
  df_glm <- cvglm_to_coeffs_by_object(list_dfs=normed_data, 
                                    test_module=identify_module(object_of_interest=object_of_interest, annotation_table=data_with_annotation, col_module_id=col_module_id, annotation_level=annotation_level),
                                    seed=seed, ...)
  if (!nrow(df_glm)) {return(tibble::tibble(.rows = 0))}
  #Filter results, keeping top 20% of coefficients
  df_glm %>% dplyr::filter(abs(coef) > quantile(abs(coef),1-filtering_top/100)) %>%  dplyr::select(-prev_level)
}
```

```{r ex-apply_NF_simple}
data(data)
res_CRC_JPN<-apply_NF_simple(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", seed=20242025)
```

```{r test-apply_NF_simple}
test_that("apply_NF_simple works", {
  data(data)
  res_CRC_JPN<-apply_NF_simple(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", seed=20242025)
  expect_equal(res_CRC_JPN$node2[1:4], c("msp_0103", "msp_0109", "msp_0148c", "msp_0208"))
})
```

# Apply NeighborFinder on raw data

```{r fun-apply_NeighborFinder}
#' Apply NeighborFinder on raw data
#' 
#' @param data_with_annotation Dataframe. The abundance table merged with the module names. Required format: modules are the rows and samples are the columns. The first column must be the modules name (e.g. species), the second is the module ID (e.g. msp), and each subsequent column is a sample
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param prev_level Numeric. The prevalence to be studied. Required format is decimal: 0.20 for 20% of prevalence
#' @param filtering_top Numeric. The filtering top percentage to be studied. Required format is: 10 for top 10% 
# @param covar String or formula. Formula or the name of the column of the covariate in the metadata table. Note that "study_accession" is equivalent to ~study_accession
# @param meta_df Dataframe. The dataframe giving metadata information
# @param sample_col String. The name of the column in metadata indicating the sample names, it should be consistent with the colnames of 'df'
#' @param ... Additional arguments passed on to [apply_NF_simple()]
#' 
#' @return Dataframe. Returns results after using NeighborFinder(): for each module ID from 'object_of_interest', the names of their neighbors and the corresponding coefficients calculated by cv.glmnet()
#' @export

apply_NeighborFinder<-function(data_with_annotation, object_of_interest, col_module_id, annotation_level, prev_level=0.30, filtering_top=20, ...){
 
 # Performance depends on the number of samples in the dataset, please choose the good comination of prev_level and filtering_top
 # The function runs for 10 seed and filters results if found in more than half the seeds to return robust results
 set.seed(seed=123)
 seeds10<-sample(1:1000000,10)
 res_repet_seeds<-data.frame()
 
 for (one_seed in seeds10) {
  res_repet_seeds<-rbind(res_repet_seeds, 
                         apply_NF_simple(data_with_annotation, object_of_interest, col_module_id,
                                         annotation_level, prev_level, filtering_top, seed = one_seed, ...) %>% 
                          dplyr::mutate(SEED=one_seed))
 } 
 if (!nrow(res_repet_seeds)){return(tibble::tibble())}
 res_repet_seeds %>% dplyr::mutate(pair=paste(node1,node2,sep="_")) %>% dplyr::group_by(pair) %>% unique() %>% 
  dplyr::summarize(seeds_detect = dplyr::n(), med=median(coef)) %>% dplyr::filter(seeds_detect>=5) %>% dplyr::select(-seeds_detect) %>%
  unique() %>% dplyr::ungroup() %>% tidyr::separate(pair, into = c("node1", "node2"), sep="_msp") %>%
  dplyr::mutate(node2=paste0("msp",node2)) %>% dplyr::rename(coef=med)
 
}
```

```{r ex-apply_NeighborFinder}
data(data)
res_CRC_JPN<-apply_NeighborFinder(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species")
```

```{r test-apply_NeighborFinder}
test_that("apply_NeighborFinder works", {
  data(data)
  res_CRC_JPN<-apply_NeighborFinder(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species")
  expect_equal(res_CRC_JPN$node2, c("msp_0103", "msp_0208", "msp_2448"))
})
```

# Display network after applying NeighborFinder

```{r fun-visualize_network}
#' Display network after applying NeighborFinder
#' 
#' @param res_NeighborFinder Dataframe. The result from apply_NeighborFinder()
#' @param annotation_table Dataframe. The dataframe gathering the taxonomic or functional module correspondence information
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#' @param annotation_option Boolean. Default value is False. If True: labels on nodes become module names instead of module IDs 
#' @param node_size Numeric. The parameter to adjust size of nodes
#' @param label_size Numeric. The parameter to adjust size of labels
#' @param object_color String. The name of the color to differentiate the nodes corresponding to 'object_of_interest' from the other module IDs
#' @param seed Numeric. The seed number, ensuring reproducibility
#' 
#' @return Network. Visualization of NeighborFinder results
#' @export

visualize_network<-function(res_NeighborFinder, annotation_table, col_module_id, annotation_level, object_of_interest, annotation_option=FALSE, node_size=12, label_size=4, object_color="cadetblue2", seed=NULL){
  if (!nrow(res_NeighborFinder)) {return(message("No neighbors were found."))}
  if (!annotation_option){
   #Build network
    res <- res_NeighborFinder
    net <- network::network(res, matrix.type="edgelist")
    network::set.edge.attribute(net, "weights", res$coef)
    #Identify species of interest in a different color
    palette <- dplyr::if_else(network::network.vertex.names(net) %in% identify_module(object_of_interest=object_of_interest, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), object_color, "grey85")
    #Plot network
    if (!is.null(seed)){set.seed(seed)}
    GGally::ggnet2(net, edge.size=20*abs(res$coef), edge.color=ifelse(res$coef>=0,"green4","red3"), edge.alpha=0.5,
           node.color=palette, size=node_size, label=TRUE, 
           legend.position="none", max_size=label_size, mode="kamadakawai", layout.exp=0.2)
  }
  else{
    #Give taxonomic correspondence
    res <- res_NeighborFinder %>%  
       dplyr::mutate(node1=module_to_node(module=node1, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), 
             node2=module_to_node(module=node2, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level)) 
    #Build network
    net <- network::network(res, matrix.type = "edgelist")
    network::set.edge.attribute(net, "weights", res$coef)
    #Identify species of interest in a different color
    palette <- dplyr::if_else(network::network.vertex.names(net) %in% module_to_node(module=identify_module(object_of_interest=object_of_interest, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), 
                                                                  annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), object_color, "grey85")
    #Plot network
    if (!is.null(seed)){set.seed(seed)}
    GGally::ggnet2(net, edge.size=20*abs(res$coef), edge.color=ifelse(res$coef>=0,"green4","red3"), edge.alpha=0.5, 
           node.color=palette, size=node_size, label=TRUE,
           legend.position="none", max_size=label_size, mode="kamadakawai", layout.exp=0.2)
  }
}
```

```{r ex-visualize_network}
data(taxo)
data(data)
res_CRC_JPN<-apply_NeighborFinder(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species")
visualize_network(res_CRC_JPN, taxo, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", label_size=5)
# #With species names instead of msp names
visualize_network(res_CRC_JPN, taxo, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", label_size=5, annotation_option=TRUE, seed=2)
# #With esthetic changes
visualize_network(res_CRC_JPN, taxo, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", annotation_option=TRUE, node_size=15, label_size=6, object_color= "orange", seed=2)
```

# Display the intersection network from 2 or more datasets

```{r fun-intersections_network}
#' Display the intersection network from 2 or more datasets
#' 
#' @param res_list List of dataframes. The results from apply_NeighborFinder() on several datasets
#' @param threshold Numeric. Integer corresponding to the minimum number of datasets in which you want neighbors to have been found
#' @param annotation_table Dataframe. The dataframe gathering the taxonomic or functional module correspondence information
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#' @param annotation_option Boolean. Default value is False. If True: labels on nodes become module names instead of module IDs 
#' @param node_size Numeric. The parameter to adjust size of nodes
#' @param label_size Numeric. The parameter to adjust size of labels
#' @param edge_label_size Numeric. The parameter to adjust the size of edge labels
#' @param object_color String. The name of the color to differentiate the nodes corresponding to 'object_of_interest' from the other module IDs
#' @param seed Numeric. The seed number, ensuring reproducibility
#' 
#' @return Network. Visualization of NeighborFinder results from several datasets
#' @export

intersections_network<-function(res_list, threshold, annotation_table, col_module_id, annotation_level, object_of_interest, annotation_option=FALSE, node_size=12, label_size=4, edge_label_size=2, object_color="cadetblue2", seed=NULL){
 #Gathering all results from datasets
 for (l in 1:length(res_list)){res_list[[l]] <- res_list[[l]] %>%  dplyr::mutate(dataset=l)}
 #Counting in how many cohorts each neighbor was found
 inter <- dplyr::bind_rows(res_list) %>% tibble::tibble() %>%   
  dplyr::mutate(pair=paste(node1,node2,sep="_")) %>% 
  dplyr::group_by(pair) %>% dplyr::summarize(intersections=list(dataset) %>% unlist() %>% length(), mean_coef=mean(coef)) %>%
  dplyr::ungroup() %>% tidyr::separate(pair, into=c("node1", "node2"), sep="_msp") %>% dplyr::mutate(node2=paste0("msp",node2))
 
 #Keeping only neighbors found in more than n cohort(s)
 res_intersections <- inter %>%  dplyr::filter(intersections >= threshold)
 if (nrow(res_intersections)==0){return(message("No intersection was found between the results provided, try to lower the threshold.\n"))}
 if (!annotation_option){
  #Build network
  net <- network::network(res_intersections, matrix.type="edgelist")
  network::set.edge.attribute(net, "weights", res_intersections$mean_coef)
  #Identify species of interest in a different color
  palette <- dplyr::if_else(network::network.vertex.names(net) %in% identify_module(object_of_interest=object_of_interest, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), object_color, "grey85")
 }
 else{
  #Give taxonomic correspondence
  res_intersections <- res_intersections %>% dplyr::mutate(node1=module_to_node(module=node1, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), 
                                                           node2=module_to_node(module=node2, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level)) 
  #Build network
  net <- network::network(res_intersections, matrix.type="edgelist")
  network::set.edge.attribute(net, "weights", res_intersections$mean_coef)
  #Identify species of interest in a different color
  palette <- dplyr::if_else(network::network.vertex.names(net) %in% module_to_node(
   module=identify_module(object_of_interest=object_of_interest, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), 
   annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), object_color, "grey85")
 }
 #Plot network
 if (!is.null(seed)){set.seed(seed)}
 GGally::ggnet2(net, edge.size=20*abs(res_intersections$mean_coef), 
                edge.color=ifelse(res_intersections$mean_coef>=0,"green4","red3"), edge.alpha=0.5, 
                edge.label=res_intersections$intersections, edge.label.color="white", 
                edge.label.fill="black", edge.label.size=edge_label_size,
                node.color=palette, size=node_size, label=TRUE,
                legend.position="none", max_size=label_size, mode="kamadakawai", layout.exp=0.2)
 
}
```

```{r ex-intersections_network}
data(taxo)
data(data)
data(metadata)
res_CRC_JPN<-apply_NeighborFinder(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species")
res_CRC_CHN<-apply_NeighborFinder(data$CRC_CHN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")
res_CRC_EUR<-apply_NeighborFinder(data$CRC_EUR, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", covar= ~ study_accession, meta_df=metadata$CRC_EUR, sample_col="secondary_sample_accession")

intersections_network(res_list=list(res_CRC_JPN, res_CRC_CHN, res_CRC_EUR), taxo, threshold=2, "Escherichia coli", col_module_id="msp_id", annotation_level="species", label_size=7, edge_label_size=4, node_size=15, annotation_option=TRUE, seed=3)
```

# Display the intersection table summarizing the results from 2 or more datasets

```{r fun-intersections_table}
#' Display the intersection table summarizing the results from 2 or more datasets
#' 
#' @param res_list List of dataframes. The results from apply_NeighborFinder() on several datasets
#' @param threshold Numeric. Integer corresponding to the minimum number of datasets in which you want neighbors to have been found
#' @param annotation_table Dataframe. The dataframe gathering the taxonomic or functional module correspondence information
#' @param col_module_id String. The name of the column with the module names in annotation_table
#' @param annotation_level String. The name of the column with the level to be studied. Examples: species, genus, level_1
#' @param object_of_interest String. The name of the bacteria or species of interest or a key word in the functional module definition
#' 
#' @return Dataframe. Table gathering the intersection of NeighborFinder results from several datasets. The column 'datasets' indicates the datasets in which the same neighbor has been found, the column 'intersections' indicates the number of datasets in which the same neighbor has been found
#' @export

intersections_table<-function(res_list, threshold, annotation_table, col_module_id, annotation_level, object_of_interest){
  #Gathering all results from datasets
  for (l in 1:length(res_list)){res_list[[l]] <- res_list[[l]] %>%  dplyr::mutate(dataset=paste("n_",l))}
  #Counting in how many cohorts each neighbor was found
 inter <-  dplyr::bind_rows(res_list) %>% tibble::tibble() %>%  
  dplyr::mutate(pair=paste(node1,node2,sep="_")) %>% 
  dplyr::group_by(pair) %>% dplyr::summarize(datasets=list(dataset), intersections=list(dataset) %>% unlist() %>% length(), mean_coef=mean(coef)) %>%
  dplyr::ungroup() %>% tidyr::separate(pair, into=c("node1", "node2"), sep="_msp") %>% dplyr::mutate(node2=paste0("msp",node2))
  
  #Keeping only neighbors found in more than n cohort(s)
  res_intersections <- inter %>%  dplyr::filter(intersections >= threshold) 
  if (nrow(res_intersections)==0){return(message("No intersection was found between the results provided, try to lower the threshold.\n"))}
  #Give taxonomic correspondence
  res_intersections %>%  dplyr::mutate(module1=module_to_node(module=node1, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level), 
                               module2=module_to_node(module=node2, annotation_table=annotation_table, col_module_id=col_module_id, annotation_level=annotation_level)) %>% 
     dplyr::select(node1,module1,node2,module2,datasets,intersections,mean_coef) %>% as.data.frame()
}
```

```{r ex-intersections_table}
data(taxo)
data(data)
data(metadata)
res_CRC_JPN<-apply_NeighborFinder(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species")
res_CRC_CHN<-apply_NeighborFinder(data$CRC_CHN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")
res_CRC_EUR<-apply_NeighborFinder(data$CRC_EUR, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", covar= ~ study_accession, meta_df=metadata$CRC_EUR, sample_col="secondary_sample_accession")

intersections_table(res_list=list(res_CRC_JPN, res_CRC_CHN, res_CRC_EUR), threshold=2, taxo, col_module_id="msp_id", annotation_level="species", "Escherichia coli")
```

```{r test-intersections_table}
test_that("intersections_table works", {
  data(taxo)
  data(data)
  data(metadata)
  res_CRC_JPN<-apply_NeighborFinder(data$CRC_JPN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species")
  res_CRC_CHN<-apply_NeighborFinder(data$CRC_CHN, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", covar= ~ study_accession, meta_df=metadata$CRC_CHN, sample_col="secondary_sample_accession")
  res_CRC_EUR<-apply_NeighborFinder(data$CRC_EUR, object_of_interest="Escherichia coli", col_module_id="msp_id", annotation_level="species", covar= ~ study_accession, meta_df=metadata$CRC_EUR, sample_col="secondary_sample_accession")
  
  table<-intersections_table(res_list=list(res_CRC_JPN, res_CRC_CHN, res_CRC_EUR), threshold=2, taxo, col_module_id="msp_id", annotation_level="species", "Escherichia coli")
  expect_equal(table$node2, c("msp_0103", "msp_0208"))
})
```


<!-- 
# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmd using `fusen::inflate()` 
-->


```{r development-inflate, eval=TRUE}
# Execute in the console directly
fusen::inflate(flat_file = "dev/NeighborFinder_flat.Rmd", vignette_name = NA)
```

```{r development-vignette}
#Generate template for vignette
# usethis::use_vignette("NeighborFinder_vignette")
```


<!-- 
- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory 
-->
